/*
 * This file is part of Hootenanny.
 *
 * Hootenanny is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * --------------------------------------------------------------------
 *
 * The following copyright notices are generated automatically. If you
 * have a new notice to add, please use the format:
 * " * @copyright Copyright ..."
 * This will properly maintain the copyright information. DigitalGlobe
 * copyrights will be updated automatically.
 *
 * @copyright Copyright (C) 2012, 2013 DigitalGlobe (http://www.digitalglobe.com/)
 */

////
// This file is automatically generated. Please do not modify the file 
// directly.
////

  // Hootenanny Javascript configuration options
  
  config = {
  
  /**
   * If true and an element already has a non-empty attribute (attribute without a default value)
   * with
   * the same key as one specified in add.attributes.visitor.kvps, then the AddAttributesVisitor
   * will not
   * add the attribute.  If false, then AddAttributesVisitor will add the attribute to the
   * element
   * regardless.
   */
  getAddAttributesVisitorAddOnlyIfEmpty : function() 
  {
      var tmp = hoot.get('add.attributes.visitor.add.only.if.empty');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * List of element attribute key/value pairs to add with the AddAttributesVisitor of the form
   * key=value.  The AddAttributesVisitor is generally used to repair a corrupted OSM output, as
   * the
   * attributes are normally added to the output automatically.  Valid key values are: changeset,
   * timestamp, user, uid, or version.
   */
  getAddAttributesVisitorKvps : function() 
  {
      var tmp = hoot.get('add.attributes.visitor.kvps');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return ""; 
  },

  /**
   * Typically REF1/2 values are only applied to elements with informational tags (e.g.
   * name=foo),
   * however setting this to false will apply REF1/2 values to all elements.
   */
  getAddRefVisitorInformationOnly : function() 
  {
      var tmp = hoot.get('add.ref.visitor.information.only');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return true; 
  },

  /**
   * Prefix to apply to REF1 values.
   * 
   * The REF1 values are typically used when training a model. See the Developer Documentation
   * for
   * details.
   */
  getAddRef1VisitorPrefix : function() 
  {
      var tmp = hoot.get('add.ref1.visitor.prefix');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return ""; 
  },

  /**
   * If true, not only will review relations receive the hoot:review:needs tag, the features
   * involved in
   * the review will receive them as well.
   */
  getAddReviewTagsToFeatures : function() 
  {
      var tmp = hoot.get('add.review.tags.to.features');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * Tag key used by AddUuidVisitor for adding custom unique ID's to data.
   */
  getAddUuidVisitorKey : function() 
  {
      var tmp = hoot.get('add.uuid.visitor.key');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return ""; 
  },

  /**
   * By default,conflation examines standard OSM tags for address comparisons (see the
   * addressTagKeys
   * file).  You can expand the tag keys searched by populating this list. From the command line,
   * separate list items with a semicolon and surround the entire list in double quotes.
   */
  getAddressAdditionalTagKeys : function() 
  {
      var tmp = hoot.get('address.additional.tag.keys');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return ""; 
  },

  /**
   * Flat file containing tag keys that make up feature address components.
   */
  getAddressTagKeysFile : function() 
  {
      var tmp = hoot.get('address.tag.keys.file');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${HOOT_HOME}/conf/core/addressTagKeys"); 
  },

  /**
   * The number of data bins used by the AngleHistogramExtractor.
   */
  getAngleHistogramExtractorBins : function() 
  {
      var tmp = hoot.get('angle.histogram.extractor.bins');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 16; 
  },

  /**
   * Smoothing value in radians used by the AngleHistogramExtractor.
   */
  getAngleHistogramExtractorSmoothing : function() 
  {
      var tmp = hoot.get('angle.histogram.extractor.smoothing');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 0.0; 
  },

  /**
   * Email address of the API database user.  Can be set here for debugging and testing.
   */
  getApiDbEmail : function() 
  {
      var tmp = hoot.get('api.db.email');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return ""; 
  },

  /**
   * Use this option if you wish to retain the file data generated during an OSM/Hootenanny API
   * database
   * write.  This option is not needed and will be ignored if writing OSM data to a SQL file that
   * will be
   * applied/written to an OSM API database at a later time.  If this option is populated, any
   * file data
   * files generated as a result of executing the hoot convert command with an OSM API database
   * target
   * are copied to the specified location.  This option should be set to a full file path to a
   * SQL
   * file (.sql).
   */
  getApidbBulkInserterOutputFilesCopyLocation : function() 
  {
      var tmp = hoot.get('apidb.bulk.inserter.output.files.copy.location');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return ""; 
  },

  /**
   * When set to true, this bypasses STXXL disk writing completely when performing data
   * validation, is
   * equivalent to apidb.bulk.inserter.validate.data=true and
   * apidb.bulk.inserter.stxxl.map.min.size=<infinity>, and overrides values passed in for those
   * settings.  If the system does not have enough memory to support in memory validation of the
   * loaded
   * features, an out of memory error will occur.
   */
  getApidbBulkInserterRunValidationInMemory : function() 
  {
      var tmp = hoot.get('apidb.bulk.inserter.run.validation.in.memory');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * First record ID to assign to written nodes when writing to an OSM/Hootenanny API database or
   * SQL
   * file.  Must be a positive number.  Use this when working with an offline database and know
   * the
   * ID range you want to assign to node records.  If writing to an OSM API databse, this option
   * is
   * ignored if "osmapidb.bulk.inserter.reserve.record.ids.before.writing.data" is set to true.
   */
  getApidbBulkInserterStartingNodeId : function() 
  {
      var tmp = hoot.get('apidb.bulk.inserter.starting.node.id');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 1; 
  },

  /**
   * First record ID to assign to written relations when writing to an OSM/Hootenanny API
   * database or
   * SQL file.  Must be a positive number.  Use this when working with an offline database and
   * know the
   * ID range you want to assign to relation records.  If writing to an OSM API database, this
   * option is
   * ignored if "osmapidb.bulk.inserter.reserve.record.ids.before.writing.data" is set to true.
   */
  getApidbBulkInserterStartingRelationId : function() 
  {
      var tmp = hoot.get('apidb.bulk.inserter.starting.relation.id');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 1; 
  },

  /**
   * First record ID to assign to written ways when writing to an OSM/Hootenanny API database or
   * SQL file.
   * Must be a positive number.  Use this when working with an offline database and know the ID
   * range you
   * want to assign to way records.  If writing to an OSM API databse, this option is
   * ignored if "osmapidb.bulk.inserter.reserve.record.ids.before.writing.data" is set to true.
   */
  getApidbBulkInserterStartingWayId : function() 
  {
      var tmp = hoot.get('apidb.bulk.inserter.starting.way.id');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 1; 
  },

  /**
   * Size at which the ID mappings storage for the OSM/Hootenanny API database bulk inserter
   * switches
   * from a std::map to an stxxl::map, which is a container optimized for very large amounts of
   * data.
   * For debugging purposes only.
   */
  getApidbBulkInserterStxxlMapMinSize : function() 
  {
      var tmp = hoot.get('apidb.bulk.inserter.stxxl.map.min.size');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 10000000; 
  },

  /**
   * Allows for customizing where the OSM/Hootenanny API database bulk inserter stores temp
   * files.
   */
  getApidbBulkInserterTempFileDir : function() 
  {
      var tmp = hoot.get('apidb.bulk.inserter.temp.file.dir');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return "/tmp"; 
  },

  /**
   * If true, the OSM/Hootenanny API database bulk inserter will renumber element IDs, check for
   * duplicated element IDs, check for invalid way node references, and check for invalid
   * relation member
   * references.  Only duplicate element IDs and invalid way node references will cause a
   * failure.
   * Invalid relation members will cause a warning to be logged.  You should enable this setting
   * if you
   * are loading data that has not been previously validated in another OSM API database.
   * Enabling this
   * setting may cause writing to an OSM API database to occur more slowly.
   */
  getApidbBulkInserterValidateData : function() 
  {
      var tmp = hoot.get('apidb.bulk.inserter.validate.data');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * The precision of numeric values written to Attribute-Relation (.arff) files.
   */
  getArffWriterPrecision : function() 
  {
      var tmp = hoot.get('arff.writer.precision');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 17; 
  },

  /**
   * If true, allows Attribute Conflation to more aggressively rejoin ways with names and
   * specific
   * highway attribution into those with less specific highway attribution and no names.
   * Enabling this
   * option may result in some false positive road joining.
   */
  getAttributeConflationAggressiveHighwayJoining : function() 
  {
      var tmp = hoot.get('attribute.conflation.aggressive.highway.joining');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * If true, allows Attribute Conflation to modify the geometry of a reference road layer to
   * accomodate
   * bridge features.  If false, any bridge features represented in the secondary dataset, but
   * not in the
   * reference dataset will be lost.
   */
  getAttributeConflationAllowRefGeometryChangesForBridges : function() 
  {
      var tmp = hoot.get('attribute.conflation.allow.ref.geometry.changes.for.bridges');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return true; 
  },

  /**
   * If true, all reviews outside of the score range established by the configuration options
   * review.score.criterion.max/min.threshold will be removed.
   */
  getAttributeConflationAllowReviewsByScore : function() 
  {
      var tmp = hoot.get('attribute.conflation.allow.reviews.by.score');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * Determines whether the AttributeScoreExtractor uses weighting when extracting scores.
   */
  getAttributeScoreExtractorUseWeight : function() 
  {
      var tmp = hoot.get('attribute.score.extractor.use.weight');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * Temporary setting that addresses some Hootenanny iD Editor UI bugs.  See
   * MatchFactory::_tempFixDefaults() for more info.
   */
  getAutocorrectOptions : function() 
  {
      var tmp = hoot.get('autocorrect.options');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return true; 
  },

  /**
   * The portion of the sqrt max of the area that the BufferedOverlapExtractor buffers object by.
   */
  getBufferedOverlapExtractorPortion : function() 
  {
      var tmp = hoot.get('buffered.overlap.extractor.portion');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 0.1; 
  },

  /**
   * Date format string used by the building date tag value.  See QDateTime::fromString for more
   * details.
   */
  getBuildingDateFormat : function() 
  {
      var tmp = hoot.get('building.date.format');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return "yyyy-MM-ddTHH:mm"; 
  },

  /**
   * Tag key used by the building.review.if.secondary.newer configuration option.
   */
  getBuildingDateTagKey : function() 
  {
      var tmp = hoot.get('building.date.tag.key');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return "source:date"; 
  },

  /**
   * If true, when buildings are auto-merged during conflation the geometry of the more complex
   * building
   * is the one that is kept.  If false or the buildings are equally complex, then the geometry
   * of the
   * reference building is the geometry kept.  This does not apply to feature merging done during
   * the
   * manual review process.
   */
  getBuildingKeepMoreComplexGeometryWhenAutoMerging : function() 
  {
      var tmp = hoot.get('building.keep.more.complex.geometry.when.auto.merging');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return true; 
  },

  /**
   * The threshold at which a match is called a match for buildings.
   * 
   * See also:
   * 
   *  * _Estimate Pairwise Relationships_, <<hootalgo>>
   */
  getBuildingMatchThreshold : function() 
  {
      var tmp = hoot.get('building.match.threshold');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${conflate.match.threshold.default}"); 
  },

  /**
   * The threshold at which a miss is called a miss for buildings.
   * 
   * See also:
   * 
   *  * _Estimate Pairwise Relationships_, <<hootalgo>>
   */
  getBuildingMissThreshold : function() 
  {
      var tmp = hoot.get('building.miss.threshold');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${conflate.miss.threshold.default}"); 
  },

  /**
   * If true, when building outlines are updated the updater will remove the source building
   * relations
   * used to create the outline multipolygon relation.  If false, both source building relations
   * and
   * outline multipolygon relations will remain.
   */
  getBuildingOutlineUpdateOpRemoveBuildingRelations : function() 
  {
      var tmp = hoot.get('building.outline.update.op.remove.building.relations');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * Number of threads used by BuildingPartMergerOp to process buildings.  A value of less than
   * one
   * allows Hootenanny to automatically determine the optimal thread count.  The default value
   * corresponds to the default number of threads available on the Hootenanny VM and you may
   * obtain
   * better performance by changing the value when dealing with other environments.
   */
  getBuildingPartMergerThreadCount : function() 
  {
      var tmp = hoot.get('building.part.merger.thread.count');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 8; 
  },

  /**
   * If true, any buildings in the secondary layer will be automatically reviewed against
   * potentially
   * matching features in the reference layer if they are marked with a more recent date than
   * that of the
   * reference feature.
   */
  getBuildingReviewIfSecondaryNewer : function() 
  {
      var tmp = hoot.get('building.review.if.secondary.newer');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * If true, any building matches other than 1:1 matches are automatically marked for review.
   */
  getBuildingReviewMatchesOtherThanOneToOne : function() 
  {
      var tmp = hoot.get('building.review.matches.other.than.one.to.one');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * The threshold at which a review is called a review for buildings.  See
   * `conflate.review.threshold.default`.
   * 
   * See also:
   * 
   *  * _Estimate Pairwise Relationships_, <<hootalgo>>
   */
  getBuildingReviewThreshold : function() 
  {
      var tmp = hoot.get('building.review.threshold');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${conflate.review.threshold.default}"); 
  },

  /**
   * If true, changesets derived can issue delete statements for the reference dataset (first
   * dataset
   * passed to the changeset deriver).  If false, no delete statements will be issued for the
   * reference
   * dataset.
   */
  getChangesetAllowDeletingReferenceFeatures : function() 
  {
      var tmp = hoot.get('changeset.allow.deleting.reference.features');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return true; 
  },

  /**
   * This is the maximum number of elements to write to an OSM API database in a changeset. This
   * value
   * is used when splitting a changeset into smaller pieces.
   * 
   * NOTE: This is different to `changeset.max.size` which is the maximum number of elements that
   * the
   * database can handle in a single changeset.
   */
  getChangesetApidbSizeMax : function() 
  {
      var tmp = hoot.get('changeset.apidb.size.max');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 1000; 
  },

  /**
   * The maximum number of writers to spawn for writing changesets in parallel to an OSM API
   * database.
   */
  getChangesetApidbWritersMax : function() 
  {
      var tmp = hoot.get('changeset.apidb.writers.max');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 10; 
  },

  /**
   * Flag to turn on throttling for OSM API changeset writes.  When turned on, each processing
   * thread
   * will wait `changeset.api.writers.throttle.time` seconds after a successful write before
   * submitting
   * another changeset to the OSM API.
   */
  getChangesetApidbWritersThrottle : function() 
  {
      var tmp = hoot.get('changeset.apidb.writers.throttle');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * The number of seconds after a successful write before submitting another changeset to the
   * OSM API.
   */
  getChangesetApidbWritersThrottleTime : function() 
  {
      var tmp = hoot.get('changeset.apidb.writers.throttle.time');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 30; 
  },

  /**
   * Value in degrees by which the specified AOI (convert.bounding.box) will be expanded when
   * calculating
   * changesets.  Setting this too large with some datasets may greatly increase the changeset
   * derivation time.
   */
  getChangesetBuffer : function() 
  {
      var tmp = hoot.get('changeset.buffer');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 0.0; 
  },

  /**
   * The text description that is written to the OSM API database with a changeset.
   */
  getChangesetDescription : function() 
  {
      var tmp = hoot.get('changeset.description');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return "Hootenanny ingest"; 
  },

  /**
   * The maximum allowed element size of an OSM changeset that can be written to an OSM API
   * database
   * in a single changeset.
   */
  getChangesetMaxSize : function() 
  {
      var tmp = hoot.get('changeset.max.size');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 50000; 
  },

  /**
   * The user ID used by certain changeset writers when writing to an OSM API database.
   */
  getChangesetUserId : function() 
  {
      var tmp = hoot.get('changeset.user.id');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return -1; 
  },

  /**
   * If true, XML changesets will add the 'timestamp' attribute to the element tags.  If false,
   * the
   * timestamp attribute will not be added.  This generally should only be set to false for
   * testing
   * purposes.
   */
  getChangesetXmlWriterAddTimestamp : function() 
  {
      var tmp = hoot.get('changeset.xml.writer.add.timestamp');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return true; 
  },

  /**
   * Set the circular error tag on features to this value, in meters, by default if the tag isn't
   * already
   * populated.
   */
  getCircularErrorDefaultValue : function() 
  {
      var tmp = hoot.get('circular.error.default.value');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 15.0; 
  },

  /**
   * Path to this file.  Only modified during testing the Hootenanny options command.
   */
  getConfigOptionsFile : function() 
  {
      var tmp = hoot.get('config.options.file');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return "conf/core/ConfigOptions.asciidoc"; 
  },

  /**
   * Path to the RF building model. A new model can be created with `build-model`. Searches local
   * path
   * and then `$HOOT_HOME/conf/`.
   */
  getConflateMatchBuildingModel : function() 
  {
      var tmp = hoot.get('conflate.match.building.model');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return "models/BuildingModel.rf"; 
  },

  /**
   * The highway match classifier to use. This should only be used for testing and debugging.
   */
  getConflateMatchHighwayClassifier : function() 
  {
      var tmp = hoot.get('conflate.match.highway.classifier');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return "hoot::HighwayRfClassifier"; 
  },

  /**
   * Path to the RF highway model. A new model can be created with `build-model`. Searches local
   * path
   * and then `$HOOT_HOME/conf/`. This is only relevant if the
   * `conflate.match.highway.classifier` is
   * set to `hoot::HighwayRfClassifier`.
   */
  getConflateMatchHighwayModel : function() 
  {
      var tmp = hoot.get('conflate.match.highway.model');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return "models/HighwayModel.rf"; 
  },

  /**
   * Path to the POI match classifier model. A new model can be created with `build-model`.
   * Searches
   * local path and then `$HOOT_HOME/conf/`.
   */
  getConflateMatchPoiModel : function() 
  {
      var tmp = hoot.get('conflate.match.poi.model');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return "models/PoiModel.rf"; 
  },

  /**
   * The default threshold at which a match is called a match.
   * 
   * See also:
   * 
   *  * _Estimate Pairwise Relationships_, <<hootalgo>>
   */
  getConflateMatchThresholdDefault : function() 
  {
      var tmp = hoot.get('conflate.match.threshold.default');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 0.6; 
  },

  /**
   * The default threshold at which a miss is called a miss.
   * 
   * See also:
   * 
   *  * _Estimate Pairwise Relationships_, <<hootalgo>>
   */
  getConflateMissThresholdDefault : function() 
  {
      var tmp = hoot.get('conflate.miss.threshold.default');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 0.6; 
  },

  /**
   * List of operations to run in the conflate command after data is conflated, but before
   * exporting.
   * 'hoot info --operators' displays information about the available operations.
   */
  getConflatePostOps : function() 
  {
      var tmp = hoot.get('conflate.post.ops');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return "hoot::SuperfluousNodeRemover;hoot::SmallWayMerger;hoot::ReplaceRoundabouts;hoot::RemoveMissingElementsVisitor;hoot::RemoveInvalidReviewRelationsVisitor;hoot::RemoveDuplicateReviewsOp;hoot::BuildingOutlineUpdateOp;hoot::WayJoinerOp;hoot::RemoveInvalidRelationVisitor;hoot::RemoveInvalidMultilineStringMembersVisitor;hoot::SuperfluousWayRemover;hoot::RemoveDuplicateWayNodesVisitor;hoot::RemoveEmptyRelationsOp;hoot::AddHilbertReviewSortOrderOp"; 
  },

  /**
   * Runs in the conflate command after data is loaded. 'hoot info --operators' displays
   * information
   * about the available operations.
   * 
   * See also: <<MapCleanerTransforms,map.cleaner.transforms>>
   */
  getConflatePreOps : function() 
  {
      var tmp = hoot.get('conflate.pre.ops');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return "hoot::BuildingOutlineRemoveOp;hoot::RemoveRoundabouts;hoot::MapCleaner;hoot::CornerSplitter"; 
  },

  /**
   * The default threshold at which a review is called a review. Reviews are also declared in
   * some
   * other situations when the relationship is not clear.
   * 
   * See also:
   * 
   *  * _Estimate Pairwise Relationships_, <<hootalgo>>
   */
  getConflateReviewThresholdDefault : function() 
  {
      var tmp = hoot.get('conflate.review.threshold.default');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 0.6; 
  },

  /**
   * The string that lists the types of conflation used in the user interface.  The possible
   * values
   * are: reference, cookieCutter, average, and advancedConflation.
   */
  getConflateStatsTypes : function() 
  {
      var tmp = hoot.get('conflate.stats.types');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return ""; 
  },

  /**
   * A JSON tag filter that is applied to filter features before conflation.  See the Hootenanny
   * User Guide "Feature Filtering" section for filter usage examples.
   */
  getConflateTagFilter : function() 
  {
      var tmp = hoot.get('conflate.tag.filter');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return ""; 
  },

  /**
   * This is the minimum valid manipulation score in the legacy greedy optimization routine.
   * Setting
   * the value lower will create more (likely overzealous) matches. Setting the value higher will
   * drop
   * less confident matches.
   */
  getConflatorMinValidScore : function() 
  {
      var tmp = hoot.get('conflator.min.valid.score');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 0.01; 
  },

  /**
   * ID of the node that ContainsNodeCriterion should search for.
   */
  getContainsNodeCriterionId : function() 
  {
      var tmp = hoot.get('contains.node.criterion.id');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 0; 
  },

  /**
   * If specified, supporting readers will limit data read from the data source to only features
   * that
   * intersect the given bounding box. The format is "minx,miny,maxx,maxy" specified in the
   * projection
   * of the input data source.  This setting can be used with both the convert and conflate
   * commands.
   * See the documentation for more details.
   * 
   * Example Usage:
   * 
   * ----
   * hoot convert -D convert.bounding.box=106.851,-6.160,107.052,-5.913 input output
   * ----
   */
  getConvertBoundingBox : function() 
  {
      var tmp = hoot.get('convert.bounding.box');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return ""; 
  },

  /**
   * Same as convert.bounding.box but the resultant bounds filtering is only applied to
   * Hootenanny API
   * database data sources when used with the convert and conflate commands.  This setting takes
   * precendence over the convert.bounding.box setting for Hootenanny API database data sources
   * only.
   */
  getConvertBoundingBoxHootApiDatabase : function() 
  {
      var tmp = hoot.get('convert.bounding.box.hoot.api.database');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return ""; 
  },

  /**
   * Same as convert.bounding.box but the resultant bounds filtering is only applied to OSM API
   * database
   * data sources when used with the convert and conflate commands.  This setting takes
   * precendence over
   * the convert.bounding.box setting for OSM API database data sources only.
   */
  getConvertBoundingBoxOsmApiDatabase : function() 
  {
      var tmp = hoot.get('convert.bounding.box.osm.api.database');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return ""; 
  },

  /**
   * Specifies one or more semi-colon delimited map operations or visitors to apply before
   * writing converted data.  This is only applicable to
   * the convert command. 'hoot info --operators' displays information about the available
   * operations.
   */
  getConvertOps : function() 
  {
      var tmp = hoot.get('convert.ops');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return ""; 
  },

  /**
   * The size in meters used for alpha by the cookie cutter map operation (CookieCutterOp). A
   * larger
   * value makes a smoother shape and a smaller value will create a rough shape with more holes.
   * Value
   * in meters.
   */
  getCookieCutterAlpha : function() 
  {
      var tmp = hoot.get('cookie.cutter.alpha');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 1000.0; 
  },

  /**
   * The buffer to add to the alpha shape before cutting by the cookie cutter map operation
   * (CookieCutterOp). A negative value will make the shape smaller.  Value in meters.
   */
  getCookieCutterAlphaShapeBuffer : function() 
  {
      var tmp = hoot.get('cookie.cutter.alpha.shape.buffer');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 0.0; 
  },

  /**
   * Crops based on the polygon rather than doing a cookie cut when using the cookie cutter map
   * operation (see CookieCutterOp).
   */
  getCookieCutterOutputCrop : function() 
  {
      var tmp = hoot.get('cookie.cutter.output.crop');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * Maximum number of nodes in a row to consider for a bend in a way to determine if the way
   * is a rounded corner that should be split.  The higher the number, the more heading
   * calculations
   * are required.  The lower the number, the less accurate it will be.
   */
  getCornerSplitterRoundedMaxNodeCount : function() 
  {
      var tmp = hoot.get('corner.splitter.rounded.max.node.count');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 6; 
  },

  /**
   * Rounded corners in one dataset can cause non-rounded corners in the secondary dataset to not
   * conflate
   */
  getCornerSplitterRoundedSplit : function() 
  {
      var tmp = hoot.get('corner.splitter.rounded.split');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * Threshold in degrees between the heading of rounded bends in way that constitutes a corner.
   */
  getCornerSplitterRoundedThreshold : function() 
  {
      var tmp = hoot.get('corner.splitter.rounded.threshold');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 55.0; 
  },

  /**
   * Threshold in degrees between the heading of two way segments that constitutes a corner.
   */
  getCornerSplitterThreshold : function() 
  {
      var tmp = hoot.get('corner.splitter.threshold');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 55.0; 
  },

  /**
   * Creates example review tags for debugging. All reviews created with this mechanism are
   * invalid.
   */
  getCreateBogusReviewTags : function() 
  {
      var tmp = hoot.get('create.bogus.review.tags');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * Bounds used by the map cropper when cropping a map, of the form: minx,miny,maxx,maxy
   */
  getCropBounds : function() 
  {
      var tmp = hoot.get('crop.bounds');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return ""; 
  },

  /**
   * Debugging: The filename to use when saving the debug map during conflation.
   */
  getDebugMapsFilename : function() 
  {
      var tmp = hoot.get('debug.maps.filename');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return "tmp/debug.osm"; 
  },

  /**
   * If true, multiple debug maps will be generated during a conflation job.  The output path of
   * the maps
   * is controlled by debug.maps.filename.  The maps can be large and slow things down
   * significantly.
   */
  getDebugMapsWrite : function() 
  {
      var tmp = hoot.get('debug.maps.write');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * If true, when running Differential Conflation the Unconnected Way Snapper will snap
   * unconnected
   * secondary road endpoint nodes to the nearest reference road.
   */
  getDifferentialSnapUnconnectedRoads : function() 
  {
      var tmp = hoot.get('differential.snap.unconnected.roads');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * List of tags to ignore when performing differential conflation with tags.
   */
  getDifferentialTagIgnoreList : function() 
  {
      var tmp = hoot.get('differential.tag.ignore.list');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return "uuid;source:datetime;license;source:imagery"; 
  },

  /**
   * Maximum angle different in degrees that two line features can have and still be considered
   * as
   * going in the same direction by DirectionFinder::isSimilarDirection2.  Used by Attribute
   * Conflation
   * only.
   */
  getDirectionFinderAngleThreshold : function() 
  {
      var tmp = hoot.get('direction.finder.angle.threshold');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 45.0; 
  },

  /**
   * WGS84 coordinate in the format: "x,y" that the DistanceNodeCriterion should use as a center
   * when
   * searching for nodes.
   */
  getDistanceNodeCriterionCenter : function() 
  {
      var tmp = hoot.get('distance.node.criterion.center');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return ""; 
  },

  /**
   * Distance in meters that the DistanceNodeCriterion should search for nodes out from a center
   * specified by 'distance.node.criterion.center'.
   */
  getDistanceNodeCriterionDistance : function() 
  {
      var tmp = hoot.get('distance.node.criterion.distance');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return -1.0; 
  },

  /**
   * When splitting divided highways, do we assume the drivers are on the right or left?
   * 
   * See also: <<MapCleanerTransforms,map.cleaner.transforms>>
   */
  getDualWaySplitterDrivingSide : function() 
  {
      var tmp = hoot.get('dual.way.splitter.driving.side');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return "right"; 
  },

  /**
   * By default how much space should be put between two divided roads when they're divided by
   * the
   * DividedHighwaySplitter. Units are in meters.
   * 
   * See also: <<MapCleanerTransforms,map.cleaner.transforms>>
   */
  getDualWaySplitterSplitSize : function() 
  {
      var tmp = hoot.get('dual.way.splitter.split.size');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 12.5; 
  },

  /**
   * If true, all cleaning and conflation merge operations will only remove duplicate names when
   * their
   * case also matches.  If false, cleaning and conflation merge operations will consider names
   * with
   * the same text but differing case as the same with each other.
   * 
   * See also: <<MapCleanerTransforms,map.cleaner.transforms>>
   */
  getDuplicateNameCaseSensitive : function() 
  {
      var tmp = hoot.get('duplicate.name.case.sensitive');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return true; 
  },

  /**
   * If true, the Duplicate Name Remover will always preserve the original name tag.  Otherwise,
   * it
   * will treat name and alternate name tags equally.
   */
  getDuplicateNamePreserveOriginalName : function() 
  {
      var tmp = hoot.get('duplicate.name.preserve.original.name');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * If true, when comparing duplicate ways, the ways and their name tags will only be merged
   * together
   * when all other non-name tags between the two match.  If false, the ways and their name tags
   * will be
   * merged together regardless of whether all of their non-name tags match.
   */
  getDuplicateWayRemoverStrictTagMatching : function() 
  {
      var tmp = hoot.get('duplicate.way.remover.strict.tag.matching');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return true; 
  },

  /**
   * The spacing used by the EdgeDistanceExtractor.  Units in meters.
   */
  getEdgeDistanceExtractorSpacing : function() 
  {
      var tmp = hoot.get('edge.distance.extractor.spacing');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 5.0; 
  },

  /**
   * Size of the in memory node cache used when streaming I/O is used with nodes.
   */
  getElementCacheSizeNode : function() 
  {
      var tmp = hoot.get('element.cache.size.node');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 10000000; 
  },

  /**
   * Size of the in memory relation cache used when streaming I/O is used with relations.
   */
  getElementCacheSizeRelation : function() 
  {
      var tmp = hoot.get('element.cache.size.relation');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 2000000; 
  },

  /**
   * Size of the in memory way cache used when streaming I/O is used with ways.
   */
  getElementCacheSizeWay : function() 
  {
      var tmp = hoot.get('element.cache.size.way');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 2000000; 
  },

  /**
   * If true, element criterions passed to an ElementCriterionConsumer will be negated.  May not
   * be
   * honored by all ElementCriterionConsumers.  Example setting which pass element criterions to
   * ElementCriterionConsumers: remove.elements.visitor.element.criterion,
   * set.tag.value.visitor.element.criterion, etc.
   */
  getElementCriterionNegate : function() 
  {
      var tmp = hoot.get('element.criterion.negate');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * The maximum number of elements allowed to be in memory during element sorting.  A value of
   * -1
   * indicates no limit.
   */
  getElementSorterElementBufferSize : function() 
  {
      var tmp = hoot.get('element.sorter.element.buffer.size');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return -1; 
  },

  /**
   * Absolute file path to dictionaries of English words. The first file found will be loaded
   * into the
   * dictionary of English words and used by some algorithms. If the files are not found then the
   * English
   * words will be silently ignored.
   */
  getEnglishWordsFiles : function() 
  {
      var tmp = hoot.get('english.words.files');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return "/usr/share/dict/american-english-insane;/usr/share/dict/american-english-huge;/usr/share/dict/american-english-large;/usr/share/dict/american-english-small;/usr/share/dict/american-english;/usr/share/dict/words"; 
  },

  /**
   * The threshold at which a match is called a match for generic lines.
   * 
   * See also:
   * 
   *  * _Estimate Pairwise Relationships_, <<hootalgo>>
   */
  getGenericLineMatchThreshold : function() 
  {
      var tmp = hoot.get('generic.line.match.threshold');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${conflate.match.threshold.default}"); 
  },

  /**
   * Sets that maximum angle that is still considered a generic line match. Units in degrees.
   */
  getGenericLineMatcherMaxAngle : function() 
  {
      var tmp = hoot.get('generic.line.matcher.max.angle');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 90.0; 
  },

  /**
   * The threshold at which a miss is called a miss for generic lines.
   * 
   * See also:
   * 
   *  * _Estimate Pairwise Relationships_, <<hootalgo>>
   */
  getGenericLineMissThreshold : function() 
  {
      var tmp = hoot.get('generic.line.miss.threshold');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${conflate.miss.threshold.default}"); 
  },

  /**
   * The threshold at which a review is called a review for generic lines. See
   * `conflate.review.threshold.default`.
   * 
   * See also:
   * 
   *  * _Estimate Pairwise Relationships_, <<hootalgo>>
   */
  getGenericLineReviewThreshold : function() 
  {
      var tmp = hoot.get('generic.line.review.threshold');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${conflate.review.threshold.default}"); 
  },

  /**
   * The way subline matcher to use when determining matching sublines with generic line
   * conflation.
   */
  getGenericLineSublineMatcher : function() 
  {
      var tmp = hoot.get('generic.line.subline.matcher');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return "hoot::MaximalSublineMatcher"; 
  },

  /**
   * The threshold at which a match is called a match for generic polygons.
   * 
   * See also:
   * 
   *  * _Estimate Pairwise Relationships_, <<hootalgo>>
   */
  getGenericPolygonMatchThreshold : function() 
  {
      var tmp = hoot.get('generic.polygon.match.threshold');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${conflate.match.threshold.default}"); 
  },

  /**
   * The threshold at which a miss is called a miss for generic polygons.
   * 
   * See also:
   * 
   *  * _Estimate Pairwise Relationships_, <<hootalgo>>
   */
  getGenericPolygonMissThreshold : function() 
  {
      var tmp = hoot.get('generic.polygon.miss.threshold');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${conflate.miss.threshold.default}"); 
  },

  /**
   * The threshold at which a review is called a review for generic polygons. See
   * `conflate.review.threshold.default`.
   * 
   * See also:
   * 
   *  * _Estimate Pairwise Relationships_, <<hootalgo>>
   */
  getGenericPolygonReviewThreshold : function() 
  {
      var tmp = hoot.get('generic.polygon.review.threshold');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${conflate.review.threshold.default}"); 
  },

  /**
   * Path to a json file containing the actions, filters and arguments used for the
   * hoot::GeometryModifierOp.
   * 
   * ==== Rule File Format
   * -----
   * {
   *     "way_to_poly":    // command: way_to_poly, collapse_poly, etc.,
   *     {
   *         "filter":     // filter for matching elements to process, element must
   *         {
   *             "aeroway": "runway"
   *         },
   *         "arguments":  // arguments specific to the selected command
   *         {
   *             "default_width_m": 10,
   *             "width_tag_m" : "width"
   *         }
   *     },
   *     "collapse_poly":  // next command: all commands defined are processed in sequence
   *     {
   *         "filter":
   *         {
   *             "building": "yes"
   *         },
   *         "arguments":
   *         {
   *             "max_area_in_m": 15000
   *         }
   *     }
   * }
   * -----
   */
  getGeometryModifierRulesFile : function() 
  {
      var tmp = hoot.get('geometry.modifier.rules.file');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${HOOT_HOME}/conf/core/GeometryModifierRules.json"); 
  },

  /**
   * The maximum number of parsed tag string values stored in an in-memory cache when reading
   * GeoNames data.
   */
  getGeonamesReaderStringCacheSize : function() 
  {
      var tmp = hoot.get('geonames.reader.string.cache.size');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 100000; 
  },

  /**
   * Sets the Qt hash seed to 0 for consistent hash values and hash based container content
   * order. This
   * is required for unit tests, but shouldn't be used in normal operation.
   */
  getHashSeedZero : function() 
  {
      var tmp = hoot.get('hash.seed.zero');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * The threshold at which a match is called a match for roads.
   * 
   * See also:
   * 
   *  * _Estimate Pairwise Relationships_, <<hootalgo>>
   */
  getHighwayMatchThreshold : function() 
  {
      var tmp = hoot.get('highway.match.threshold');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 0.161; 
  },

  /**
   * The distance around a point on a highway to look when calculating the heading.  See
   * `way.matcher.heading.delta`.
   */
  getHighwayMatcherHeadingDelta : function() 
  {
      var tmp = hoot.get('highway.matcher.heading.delta');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${way.matcher.heading.delta}"); 
  },

  /**
   * Sets that maximum angle that is still considered a highway match. Units in degrees.
   */
  getHighwayMatcherMaxAngle : function() 
  {
      var tmp = hoot.get('highway.matcher.max.angle');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${way.matcher.max.angle}"); 
  },

  /**
   * If two highways have significantly different enumerated types then they will not be
   * considered
   * for match. For example:
   * 
   * * "highway=primary" vs "highway=secondary" has a diff of 0.2.
   * * "highway=primary" vs "highway=footway" has a diff of 0.67.
   */
  getHighwayMaxEnumDiff : function() 
  {
      var tmp = hoot.get('highway.max.enum.diff');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 0.6; 
  },

  /**
   * If true, road conflation merges tag changes into the reference only and makes no geometry
   * changes.
   */
  getHighwayMergeTagsOnly : function() 
  {
      var tmp = hoot.get('highway.merge.tags.only');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * The threshold at which a miss is called a miss for roads.
   * 
   * See also:
   * 
   *  * _Estimate Pairwise Relationships_, <<hootalgo>>
   */
  getHighwayMissThreshold : function() 
  {
      var tmp = hoot.get('highway.miss.threshold');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 0.999; 
  },

  /**
   * The threshold at which a review is called a review for roads. See
   * `conflate.review.threshold.default`.
   * 
   * See also:
   * 
   *  * _Estimate Pairwise Relationships_, <<hootalgo>>
   */
  getHighwayReviewThreshold : function() 
  {
      var tmp = hoot.get('highway.review.threshold');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 0.25; 
  },

  /**
   * The highway subline matcher to use when determining matching highway sublines.
   */
  getHighwaySublineMatcher : function() 
  {
      var tmp = hoot.get('highway.subline.matcher');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${way.subline.matcher}"); 
  },

  /**
   * The way subline string matcher to use when determining matching sublines for highways.
   */
  getHighwaySublineStringMatcher : function() 
  {
      var tmp = hoot.get('highway.subline.string.matcher');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${way.subline.string.matcher}"); 
  },

  /**
   * OpenstreetMap OAuth Access Token for gaining access to the OAuth protected OSM API
   */
  getHootOsmAuthAccessToken : function() 
  {
      var tmp = hoot.get('hoot.osm.auth.access.token');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return ""; 
  },

  /**
   * OpenstreetMap OAuth Private Access Token for gaining access to the OAuth protected OSM API
   */
  getHootOsmAuthAccessTokenSecret : function() 
  {
      var tmp = hoot.get('hoot.osm.auth.access.token.secret');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return ""; 
  },

  /**
   * OpenstreetMap OAuth Consumer Key found after registering Hootenanny with OpenstreetMap (or
   * its
   * derivatives) at http://<OSM Domain>/user/<your username>/oauth_clients
   */
  getHootOsmAuthConsumerKey : function() 
  {
      var tmp = hoot.get('hoot.osm.auth.consumer.key');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return ""; 
  },

  /**
   * OpenstreetMap OAuth Private Consumer Key found after registering Hootenanny with
   * OpenstreetMap (or its
   * derivatives) at http://<OSM Domain>/user/<your username>/oauth_clients
   */
  getHootOsmAuthConsumerSecret : function() 
  {
      var tmp = hoot.get('hoot.osm.auth.consumer.secret');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return ""; 
  },

  /**
   * Hootenanny Web Services public access token required by some Hootenanny commands.  Use the
   * Hootenanny 'login' command to retrieve access tokens.
   */
  getHootServicesAuthAccessToken : function() 
  {
      var tmp = hoot.get('hoot.services.auth.access.token');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return ""; 
  },

  /**
   * Hootenanny Web Services private access token required by some Hootenanny commands.  Use the
   * Hootenanny 'login' command to retrieve access tokens.
   */
  getHootServicesAuthAccessTokenSecret : function() 
  {
      var tmp = hoot.get('hoot.services.auth.access.token.secret');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return ""; 
  },

  /**
   * Host name of the machine the Hootenanny Web Services are located on.
   */
  getHootServicesAuthHost : function() 
  {
      var tmp = hoot.get('hoot.services.auth.host');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return "localhost"; 
  },

  /**
   * Port of the machine the Hootenanny Web Services are located on.  If left empty, port 80 will
   * be
   * used.
   */
  getHootServicesAuthPort : function() 
  {
      var tmp = hoot.get('hoot.services.auth.port');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 8080; 
  },

  /**
   * Hootenanny Web Services user name associated with an authenticated login.
   */
  getHootServicesAuthUserName : function() 
  {
      var tmp = hoot.get('hoot.services.auth.user.name');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return ""; 
  },

  /**
   * If set to true, the Hootenanny API database writer will insert new records using Postgres
   * COPY
   * statements, which may increase performance when writing large datasets.  This setting can
   * only
   * be activated when writing new records and will not work when existing records need to be
   * modified
   * or deleted.  It also requires writing out temporary files, so extra disk space is needed.
   */
  getHootapiDbWriterCopyBulkInsert : function() 
  {
      var tmp = hoot.get('hootapi.db.writer.copy.bulk.insert');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * Should the hootapi services DB writer automatically create the specified user if it doesn't
   * exist.
   * This is most useful when debugging and testing.
   */
  getHootapiDbWriterCreateUser : function() 
  {
      var tmp = hoot.get('hootapi.db.writer.create.user');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * This option allows the Hootenanny Web Services to pass in the ID of the currently executing
   * command
   * job.  Given that information, any Hootenanny API database writer invoked by the command will
   * write
   * the ID of the job's associated map to the job status table.
   */
  getHootapiDbWriterJobId : function() 
  {
      var tmp = hoot.get('hootapi.db.writer.job.id');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return ""; 
  },

  /**
   * If this value is set to a non-empty string, the system will attempt to open a file with the
   * specified name and output all the ID mappings (source to destination) used for nodes, ways,
   * and
   * relations that were written to the database.
   */
  getHootapiDbWriterOutputIdMappings : function() 
  {
      var tmp = hoot.get('hootapi.db.writer.output.id.mappings');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return ""; 
  },

  /**
   * If set to true then if there is already a map with the specified name then it will be
   * removed before
   * a new map is written.
   */
  getHootapiDbWriterOverwriteMap : function() 
  {
      var tmp = hoot.get('hootapi.db.writer.overwrite.map');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * If this value is set to true, then all incoming element IDs are remapped into new IDs as the
   * elements are written to a Hootenanny API database, otherwise the original IDs from the map
   * are preserved.
   */
  getHootapiDbWriterRemapIds : function() 
  {
      var tmp = hoot.get('hootapi.db.writer.remap.ids');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * Sets the default ID generator class name. This determines how Hootenanny will assign new
   * element
   * IDs as they're created. The `DefaultIdGenerator` assigns IDs in a decrementing fashion (e.g.
   * -1,
   * -2, ...). The `hoot::PositiveIdGenerator` increments the IDs (e.g. 1, 2, 3, ...).
   * 
   * Both generators maintain a different count for each element type. E.g. you can have a Node
   * with ID
   * 1 and a Way with ID 1. This will not cause any problems within Hootenanny and is a
   * legitimate way
   * of assigning IDs within OSM.
   * 
   * Example Usage:
   * 
   * ----
   * hoot convert -D id.generator=hoot::PositiveIdGenerator -D id.generator.node.start=100 -D
   * id.generator.relation.start=200 -D id.generator.way.start=300 myinput.osm myoutput.osm
   * --trans $HOOT_HOME/translations/Identity.js
   * ----
   */
  getIdGenerator : function() 
  {
      var tmp = hoot.get('id.generator');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return "hoot::DefaultIdGenerator"; 
  },

  /**
   * Sets the default start ID for nodes. The first value assigned is generator specific. (E.g.
   * for
   * default the first assigned id will be -1)
   */
  getIdGeneratorNodeStart : function() 
  {
      var tmp = hoot.get('id.generator.node.start');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 0; 
  },

  /**
   * Sets the default start ID for relations. The first value assigned is generator specific.
   * (E.g.
   * for default the first assigned id will be -1)
   */
  getIdGeneratorRelationStart : function() 
  {
      var tmp = hoot.get('id.generator.relation.start');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 0; 
  },

  /**
   * Sets the default start ID for ways. The first value assigned is generator specific. (E.g.
   * for
   * default the first assigned id will be -1)
   */
  getIdGeneratorWayStart : function() 
  {
      var tmp = hoot.get('id.generator.way.start');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 0; 
  },

  /**
   * If true, implicit taggers will only add the implicit tag to the element with the highest tag
   * occurrence count for a given set of inputs name tokens.  Setting to true may be useful in
   * reducing
   * false positive applied tags to elements.
   */
  getImplicitTaggerAddTopTagOnly : function() 
  {
      var tmp = hoot.get('implicit.tagger.add.top.tag.only');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return true; 
  },

  /**
   * A list of additional tag keys to be considered as names when tagging implicitly based on
   * type.
   */
  getImplicitTaggerAdditionalNameKeys : function() 
  {
      var tmp = hoot.get('implicit.tagger.additional.name.keys');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return "note"; 
  },

  /**
   * If true, implicit taggers will attempt to add more specific tags to existing non-generic
   * elements
   * (dependent on the element type filter; e.g. for POIs, elements with a tag more specific than
   * "poi=yes").  If false, implicit taggers will ignore all non-generic elements during implicit
   * tagging.
   */
  getImplicitTaggerAllowTaggingSpecificEntities : function() 
  {
      var tmp = hoot.get('implicit.tagger.allow.tagging.specific.entities');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return true; 
  },

  /**
   * If true, implicit taggers will allow for returning tags for a name when that name is
   * involved in
   * more than one tagging rule.  Setting to false may be useful in reducing false positive
   * applied tags
   * to elements.
   */
  getImplicitTaggerAllowWordsInvolvedInMultipleRules : function() 
  {
      var tmp = hoot.get('implicit.tagger.allow.words.involved.in.multiple.rules');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * If true, implicit taggers will attempt to match the last token in a name to an implicit tag
   * rule
   * first before attempting to match other parts of the name.  Setting to true can be useful in
   * getting
   * better tagging performance for names that would otherwise be involved in multiple implicit
   * tag
   * rules.
   */
  getImplicitTaggerMatchEndOfNameSingleTokenFirst : function() 
  {
      var tmp = hoot.get('implicit.tagger.match.end.of.name.single.token.first');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return true; 
  },

  /**
   * The maximum length a name tag value can have for the type tagger to try and derive a type
   * from it.
   */
  getImplicitTaggerMaxNameLength : function() 
  {
      var tmp = hoot.get('implicit.tagger.max.name.length');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 75; 
  },

  /**
   * Database used by the POI implicit tagger to derive POI type tags implicitly based on a POI's
   * name.
   */
  getImplicitTaggerRulesDatabase : function() 
  {
      var tmp = hoot.get('implicit.tagger.rules.database');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${HOOT_HOME}/conf/core/implicit-tag-rules/osm-geonames-4-5-18.sqlite"); 
  },

  /**
   * Flat file containing tab separated word key/value pairs to use as custom rules when deriving
   * an
   * implicit tags database from POI names.
   */
  getImplicitTaggingDatabaseDeriverCustomRuleFile : function() 
  {
      var tmp = hoot.get('implicit.tagging.database.deriver.custom.rule.file');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${HOOT_HOME}/conf/core/implicit-tag-rules/implicitTagRulesCustomRuleList"); 
  },

  /**
   * The minimum number of times a tag must be associated with a word in order for an implicit
   * tag rule
   * to be created that is associated with it.
   */
  getImplicitTaggingDatabaseDeriverMinimumTagOccurrencesPerWord : function() 
  {
      var tmp = hoot.get('implicit.tagging.database.deriver.minimum.tag.occurrences.per.word');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 1000; 
  },

  /**
   * The minimum allowed word length when associating word tokens with tags.
   */
  getImplicitTaggingDatabaseDeriverMinimumWordLength : function() 
  {
      var tmp = hoot.get('implicit.tagging.database.deriver.minimum.word.length');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 3; 
  },

  /**
   * Flat file containing key/value pairs to ignore when deriving an implicit tags database from
   * POI
   * names.  Use 'key=*' to ignore all tags for a given key.
   */
  getImplicitTaggingDatabaseDeriverTagIgnoreFile : function() 
  {
      var tmp = hoot.get('implicit.tagging.database.deriver.tag.ignore.file');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${HOOT_HOME}/conf/core/implicit-tag-rules/implicitTagRulesTagIgnoreList"); 
  },

  /**
   * If true, the implicit tag raw rules deriver will translate name words to English as implicit
   * tag
   * rules are derived.
   */
  getImplicitTaggingDatabaseDeriverTranslateNamesToEnglish : function() 
  {
      var tmp = hoot.get('implicit.tagging.database.deriver.translate.names.to.english');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * If true, the implicit tag raw rules generator will only consider words that correspond to a
   * OSM tag
   * value in the Hootenanny schema.
   */
  getImplicitTaggingDatabaseDeriverUseSchemaTagValuesForWordsOnly : function() 
  {
      var tmp = hoot.get('implicit.tagging.database.deriver.use.schema.tag.values.for.words.only');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return true; 
  },

  /**
   * Flat file containing words to ignore when deriving an implicit tags database from POI names.
   */
  getImplicitTaggingDatabaseDeriverWordIgnoreFile : function() 
  {
      var tmp = hoot.get('implicit.tagging.database.deriver.word.ignore.file');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${HOOT_HOME}/conf/core/implicit-tag-rules/implicitTagRulesWordIgnoreList"); 
  },

  /**
   * Criterion class inheriting from hoot::ImplicitTagEligibleCriterion; The default,
   * ImplicitTagEligiblePoiPolyCriterion, derives tag information from POIs, buildings, and
   * areas.  To
   * pass in more nested criterion, use the Hootenanny Javascript interface instead.
   */
  getImplicitTaggingElementCriterion : function() 
  {
      var tmp = hoot.get('implicit.tagging.element.criterion');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return "hoot::ImplicitTagEligiblePoiPolyCriterion"; 
  },

  /**
   * If true, the implicit tag raw rules/database derivers will keep all temporary file output.
   * For
   * debugging only.
   */
  getImplicitTaggingKeepTempFiles : function() 
  {
      var tmp = hoot.get('implicit.tagging.keep.temp.files');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * Flat file containing tokens that should be ignored in names when deriving implicit type
   * tagging
   * rules or when determining whether to type tag an element using implicit tagging.
   */
  getImplicitTaggingNameCleaningTokensFile : function() 
  {
      var tmp = hoot.get('implicit.tagging.name.cleaning.tokens.file');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${HOOT_HOME}/conf/core/implicit-tag-rules/implicitTagRulesNameCleaningTokens"); 
  },

  /**
   * If true, the implicit tag raw rules deriver will skip node filtering.  Only set to true if
   * the input
   * data has been filtered with ImplicitTagEligiblePoiCriterion beforehand.
   */
  getImplicitTaggingRawRulesDeriverSkipFiltering : function() 
  {
      var tmp = hoot.get('implicit.tagging.raw.rules.deriver.skip.filtering');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * The number of parallel processes used when sorting output by the implicit tag raw rules
   * deriver.
   * The default value of -1 uses a count equal to the number of processors on the machine.
   * Valid values
   * are -1 or 1 up to the number of available processors.
   */
  getImplicitTaggingRawRulesDeriverSortParallelCount : function() 
  {
      var tmp = hoot.get('implicit.tagging.raw.rules.deriver.sort.parallel.count');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return -1; 
  },

  /**
   * If true, all implicit taggers will translate element name words to English before querying
   * the
   * corresponding implicit tag rules database.
   */
  getImplicitTaggingTranslateNamesToEnglish : function() 
  {
      var tmp = hoot.get('implicit.tagging.translate.names.to.english');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * A list of paths to include in the javascript translator search path.
   */
  getJavascriptTranslatorPath : function() 
  {
      var tmp = hoot.get('javascript.translator.path');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${HOOT_TRANSLATE_PATH};${HOOT_HOME}/plugins;${HOOT_HOME}/plugins-local;${HOOT_HOME}/rules"); 
  },

  /**
   * Output JSON in a more Hootenanny specific way that includes Hootenanny-specific tags
   * including `hoot:*`, `error:circluar`, `type=node/way/relation`, tags in the `tags`
   * section, etc.
   * 
   * `Generic Format`
   * -----
   * ...
   * {
   *   "type":"Feature",
   *   "properties":{
   *     "type":"LineString",
   *     "REF1":"Panera",
   *     "access":{ "groups":[],"users":[] },
   *     "attributes":{
   *       "item_date":"2017-10-09T12:34:56.789Z",
   *       "category_id":"123456",
   *       "asset_id":"ABC123"
   *       },
   *     "alt_name":null,
   *     "building":"yes",
   *     "name":"Panera Bread",
   *     "item_type":[ "building","restaurant" ],
   *     },
   *   "geometry":{
   *     "type":"Polygon",
   *     "coordinates":[[[-104.8065566424573,39.59327717293566],
   *                     [-104.8061245919961,39.59330667331412],
   *                     [-104.8060931452853,39.59315284977403],
   *                     [-104.8065292974914,39.59311913497989],
   *                     [-104.8065566424573,39.59327717293566]]]
   *     }
   * },
   * ...
   * -----
   * vs
   * `Hootenanny-specific Format`
   * -----
   * ...
   * {
   *   "type":"Feature",
   *   "id":"-2",
   *   "properties":{
   *     "type":"way",
   *     "tags":{
   *       "REF1":"Panera",
   *       "access":{ "groups":[],"users":[] },
   *       "attributes":{
   *         "item_date":"2017-10-09T12:34:56.789Z",
   *         "category_id":"123456",
   *         "asset_id":"ABC123"
   *         },
   *       "alt_name":null,
   *       "building":"yes",
   *       "type":"way",
   *       "name":"Panera Bread",
   *       "item_type":[ "building","restaurant" ],
   *       "error:circular":"15"
   *       }
   *     },
   *   "geometry":{
   *     "type":"Polygon",
   *     "coordinates":[[[-104.8065566424573,39.59327717293566],
   *                     [-104.8061245919961,39.59330667331412],
   *                     [-104.8060931452853,39.59315284977403],
   *                     [-104.8065292974914,39.59311913497989],
   *                     [-104.8065566424573,39.59327717293566]]]
   *     }
   * },
   * ...
   * -----
   */
  getJsonFormatHootenanny : function() 
  {
      var tmp = hoot.get('json.format.hootenanny');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * Write out empty OSM tags to JSON such as `"text":""`
   */
  getJsonPerserveEmptyTags : function() 
  {
      var tmp = hoot.get('json.perserve.empty.tags');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return true; 
  },

  /**
   * Write out JSON in a more legible manner
   */
  getJsonPrettyPrint : function() 
  {
      var tmp = hoot.get('json.pretty.print');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * Maximum size of an HTTP request's bounding box in degrees before it is split up into smaller
   * bounding
   * boxes and run in parallel
   */
  getJsonReaderHttpBboxMaxSize : function() 
  {
      var tmp = hoot.get('json.reader.http.bbox.max.size');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 0.25; 
  },

  /**
   * Split the bounding box of an HTTP read request into smaller bounding boxes that can be run
   * in parallel
   */
  getJsonReaderHttpBboxParallel : function() 
  {
      var tmp = hoot.get('json.reader.http.bbox.parallel');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * Number of threads in the thread pool to process HTTP requests that contain bounding boxes
   * that are too
   * large to query at once (see `json.reader.http.bbox.max.size`).
   */
  getJsonReaderHttpBboxThreadCount : function() 
  {
      var tmp = hoot.get('json.reader.http.bbox.thread.count');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 8; 
  },

  /**
   * A list of tag keys for which the KeepTagsVisitor will retain on elements, while removing all
   * other tags from elements.
   */
  getKeepTagsVisitorKeys : function() 
  {
      var tmp = hoot.get('keep.tags.visitor.keys');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return ""; 
  },

  /**
   * LanguageDetector implementation to use for detecting source languages.  If using
   * hoot::HootServicesLanguageDetectorClient, a translation server must be set up and valid
   * OAuth
   * credentials used.  Also, be sure to use an appropriate value for the
   * 'language.info.provider'
   * option.
   */
  getLanguageDetectionDetector : function() 
  {
      var tmp = hoot.get('language.detection.detector');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return "hoot::HootServicesLanguageDetectorClient"; 
  },

  /**
   * If true, source languages detected for tags will be written in new tags to output.  If
   * false, no
   * tags are written and only a summary of the source languages found will be printed at
   * completion.
   */
  getLanguageDetectionWriteDetectedLangTags : function() 
  {
      var tmp = hoot.get('language.detection.write.detected.lang.tags');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * The minimum language detection confidence threshold to use when detecting languages in text
   * using
   * hoot::HootServicesLanguageDetectorClient.  Valid values are: 'low', 'medium', 'high', or
   * 'none'.  A
   * value of 'none' or an empty string disables the threshold.  Not all server side language
   * detectors
   * specified in 'language.hoot.services.detectors' support detection confidence.  When listing
   * server
   * side detectors via the API, confidence support information is included.
   */
  getLanguageHootServicesDetectionMinConfidenceThreshold : function() 
  {
      var tmp = hoot.get('language.hoot.services.detection.min.confidence.threshold');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return "high"; 
  },

  /**
   * When using 'HootServicesTranslatorClient' as the to English language translator or
   * HootServicesLanguageDetectorClient as a source
   * language detector, one or more hoot-services Java class names implementing LanguageDetector.
   * Language detectors are used in order of
   * entry. 'hoot info --languages --detectors' displays information about the available server
   * side detectors. If no detectors are specified, then
   * language translation will attempt to use as many detectors as needed, in a pre-determined
   * order, to get a positive detection.
   * Separate values with a ';' and surround in quotes when passing in from the command line.
   */
  getLanguageHootServicesDetectors : function() 
  {
      var tmp = hoot.get('language.hoot.services.detectors');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return "TikaLanguageDetector;OpenNlpLanguageDetector"; 
  },

  /**
   * If true and performing a to English translation with ToEnglishTranslationVisitor, the
   * translator
   * will skip attempting to translate any tags whose owning elements have a pre-translated
   * English tag
   * (key=<tag name>:en). If true and performing a non-English source language detection with
   * NonEnglishLanguageDetectionVisitor, the detector will ignore the fact that an English pre-
   * translated
   * tag already exists on the associated element and attempt to detect the source language of
   * the
   * pre-translated tag.
   */
  getLanguageIgnorePreTranslatedTags : function() 
  {
      var tmp = hoot.get('language.ignore.pre.translated.tags');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * LanguageInfoProvider implementation to use for determining language information needed by to
   * English translation. If using hoot::HootServicesLanguageInfoClient, a translation server
   * must be
   * set up and valid OAuth credentials used.
   */
  getLanguageInfoProvider : function() 
  {
      var tmp = hoot.get('language.info.provider');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return "hoot::HootServicesLanguageInfoClient"; 
  },

  /**
   * Maximum result cache sized used for to English translation and source language detection.
   * Not
   * necessarily honored by all translators/detectors.  A cache size of -1 disables the
   * translation
   * cache.
   */
  getLanguageMaxCacheSize : function() 
  {
      var tmp = hoot.get('language.max.cache.size');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 10000; 
  },

  /**
   * When performing a to English translation or source language detection, the
   * translator/detector
   * by default uses the required 'language.tag.keys' configuration option to determine which
   * tags to
   * translate or detect source languages for.  If this option is enabled, 'language.tag.keys' is
   * no
   * longer a required option and all name tags will be parsed during translation/detection.  If
   * 'language.tag.keys' is populated in addition to enabling this option, then any tag keys in
   * 'language.tag.keys' that are not names will be parsed in addition to the name tags.
   */
  getLanguageParseNames : function() 
  {
      var tmp = hoot.get('language.parse.names');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * When performing a to English translation or source language detection, the
   * translator/detector
   * will skip the translation of any tags whose value is in an English dictionary.
   */
  getLanguageSkipWordsInEnglishDictionary : function() 
  {
      var tmp = hoot.get('language.skip.words.in.english.dictionary');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return true; 
  },

  /**
   * A list of keys of tags whose values are to either be translated to English by a
   * ToEnglishTranslationVisitor or just have their source languages detected by a
   * LanguageDetectionVisitor depending on the operation being performed. Separate keys with a
   * ';' and
   * surround in quotes when passing in from the command line.
   */
  getLanguageTagKeys : function() 
  {
      var tmp = hoot.get('language.tag.keys');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return ""; 
  },

  /**
   * A list of tag keys whose values are known to have been previously translated to the desired
   * target
   * language.  The list ordering should correspond to that of language.tag.keys.  Separate keys
   * with a
   * ';' and surround in quotes when passing in from the command line.
   */
  getLanguageTranslationComparisonPretranslatedTagKeys : function() 
  {
      var tmp = hoot.get('language.translation.comparison.pretranslated.tag.keys');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return ""; 
  },

  /**
   * StringDistance implementation used to score to English translated tag values
   */
  getLanguageTranslationComparisonScorer : function() 
  {
      var tmp = hoot.get('language.translation.comparison.scorer');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return "hoot::LevenshteinDistance"; 
  },

  /**
   * If source languages are specified that do not match the detected language for piece of text
   * during
   * translation, setting this to true allows the detected language to override the specified
   * source
   * languages.
   */
  getLanguageTranslationDetectedLanguageOverridesSpecifiedSourceLanguages : function() 
  {
      var tmp = hoot.get('language.translation.detected.language.overrides.specified.source.languages');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * When using 'hoot::HootServicesTranslatorClient' as the to English language translator, a
   * hoot-services Java class names implementing ToEnglishTranslator.  Valid values are
   * 'JoshuaLanguageTranslator' and 'HootLanguageTranslator'.
   */
  getLanguageTranslationHootServicesTranslator : function() 
  {
      var tmp = hoot.get('language.translation.hoot.services.translator');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return "HootLanguageTranslator"; 
  },

  /**
   * If more than one source language is specified for to English translation and the correct
   * source language cannot be detected, translation attempts will be made against each specified
   * languages until a translation is found.  Enabling this option can have a large impact on
   * translation
   * performance due to language detection cost.
   */
  getLanguageTranslationPerformExhaustiveSearchWithNoDetection : function() 
  {
      var tmp = hoot.get('language.translation.perform.exhaustive.search.with.no.detection');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * ISO-639-1 language codes for the source languages for to English translation
   * (https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes).  Also, you can specify a single
   * list item,
   * "detect", to attempt to auto-detect the appropriate source language before translation.
   * Specifying
   * multiple source languages can have a large impact on translation performance due to language
   * detection cost.  Separate list items with a ';' and surround in quotes when passing them in
   * from
   * the command line.
   */
  getLanguageTranslationSourceLanguages : function() 
  {
      var tmp = hoot.get('language.translation.source.languages');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return ""; 
  },

  /**
   * ToEnglishTranslator implementation to use for to English translation.
   * hoot::HootServicesTranslatorClient, requires a translation server be set up and valid OAuth
   * credentials used.  Also, be sure to use an appropriate value for the
   * 'language.info.provider'
   * option.
   */
  getLanguageTranslationTranslator : function() 
  {
      var tmp = hoot.get('language.translation.translator');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return "hoot::HootServicesTranslatorClient"; 
  },

  /**
   * Raise the Levenshtein score to this power before returning this result. If alpha is greater
   * than
   * 1 then this makes low scores even lower. Valid values are > 0.
   * 
   * The default alpha value of 1.15 was determined through experimentation with a Jakarta data
   * set
   * using MeanWordSetDistance as the container classes. See Redmine ticket #2349 for some
   * experiment
   * details.  The "best" value varies depending on the input data as well as how the data is
   * being used.
   */
  getLevenshteinDistanceAlpha : function() 
  {
      var tmp = hoot.get('levenshtein.distance.alpha');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 1.15; 
  },

  /**
   * Absolute path to the directory where the libpostal library, used for address parsing, stores
   * its
   * data.
   */
  getLibpostalDataDir : function() 
  {
      var tmp = hoot.get('libpostal.data.dir');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return "/usr/share/libpostal"; 
  },

  /**
   * If available, uses the formatting as defined in
   * https://svn.apache.org/repos/asf/logging/site/trunk/docs/log4cxx/apidocs/classlog4cxx_1_1_pa
   * ttern_layout.html[log4cxx]
   * to set the log format. If log4cxx isn't available then this has no effect.
   * 
   * Some example format strings and the associated output are below:
   * 
   * -----
   * # Default log message with lots of information
   * %d{HH:mm:ss.SSS} %-5p ...%.30F(%4L) %m%n
   * 12:36:03.565 INFO  ...conflate/UnifyingConflator.cpp( 154) Pre-constraining match count: 11
   * 
   * # Log message w/ minimal information
   * %-5p..%.20F(%3L) %m%n
   * INFO ..nifyingConflator.cpp(154) Pre-constraining match count: 11
   * 
   * # Embed arbitrary strings in the log messages
   * Foo: %m%n
   * Foo: Pre-constraining match count: 11
   * 
   * # Print out time elapsed in ms along w/ other info
   * %6r %-5p..%.20F(%3L) %m%n
   *    289 INFO ..nifyingConflator.cpp(154) Pre-constraining match count: 11
   * 
   * # XML-ish log message. This allows parsing messages that span multiple lines,
   * # but you aren't guaranteed that all output from hoot goes through the logging
   * # mechanism.
   * <message time='%d' level='%p' file='%F' line='%L'>%m</message>%n
   * <message time='2014-10-28 13:09:35,339' level='INFO'
   * file='src/main/cpp/hoot/core/conflate/UnifyingConflator.cpp' line='154'>Pre-constraining
   * match count: 11</message>
   * -----
   */
  getLogFormat : function() 
  {
      var tmp = hoot.get('log.format');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return "%d{HH:mm:ss.SSS} %-5p ...%.30F(%4L) %m%n"; 
  },

  /**
   * The maximum number of warn log messages that will be emitted per class before they are
   * silenced.
   * A value of -1 passed to class will ensure that no warnings are logged by it, if it honors
   * the option.
   * A setting of -1 is useful for tests where you do not have granular enough logging control.
   * 
   * [[MapCleanerTransforms]]
   */
  getLogWarnMessageLimit : function() 
  {
      var tmp = hoot.get('log.warn.message.limit');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 3; 
  },

  /**
   * A list of map operations to be applied to a map for cleaning purposes, in order.
   * 'hoot info --operators' displays information about the available transforms.
   * 
   * [[match.creators]]
   */
  getMapCleanerTransforms : function() 
  {
      var tmp = hoot.get('map.cleaner.transforms');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return "hoot::ReprojectToPlanarOp;hoot::OneWayRoadStandardizer;hoot::DuplicateWayRemover;hoot::SuperfluousWayRemover;hoot::IntersectionSplitter;hoot::UnlikelyIntersectionRemover;hoot::DualWaySplitter;hoot::ImpliedDividedMarker;hoot::DuplicateNameRemover;hoot::SmallWayMerger;hoot::RemoveEmptyAreasVisitor;hoot::RemoveDuplicateRelationMembersVisitor;hoot::RelationCircularRefRemover;hoot::RemoveEmptyRelationsOp;hoot::RemoveDuplicateAreaVisitor;hoot::NoInformationElementRemover"; 
  },

  /**
   * List of match creators to use during conflation. This can modify what features will be
   * conflated
   * (e.g. buildings, roads, etc.).  The ordering must match that in merger.creators.
   * 'hoot info --matchers' displays information about the available matchers.
   */
  getMatchCreators : function() 
  {
      var tmp = hoot.get('match.creators');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return "hoot::BuildingMatchCreator;hoot::ScriptMatchCreator,PoiGeneric.js;hoot::HighwayMatchCreator;hoot::ScriptMatchCreator,LinearWaterway.js;hoot::PoiPolygonMatchCreator;hoot::ScriptMatchCreator,Area.js;hoot::ScriptMatchCreator,Railway.js;hoot::ScriptMatchCreator,PowerLine.js"; 
  },

  /**
   * Used in the calculation of the match parallel score, cos (delta) ^ match.parallel.exponent
   */
  getMatchParallelExponent : function() 
  {
      var tmp = hoot.get('match.parallel.exponent');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 1; 
  },

  /**
   * Maximum number of elements that will be read into memory at one time during a partial OSM
   * map
   * reading.  This shouldn't need to be changed.  Reducing the value may cause errors on some
   * data
   * formats that read large numbers of entries at one time. Increasing the value will use more
   * RAM in
   * some situations.
   */
  getMaxElementsPerPartialMap : function() 
  {
      var tmp = hoot.get('max.elements.per.partial.map');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 100000; 
  },

  /**
   * Allows for artificially limiting the amount of virtual memory that Hootenanny will use. If
   * Hootenanny needs more than this amount of virtual memory then a bad_alloc will likely be
   * thrown.
   * In some cases you will receive a totally unrelated error message.
   * 
   * Size is specified in bytes unless followed by one of these suffixes.
   * 
   * * KB = size * 1000
   * * MB = size * 1000 * 1000
   * * GB = size * 1000 * 1000 * 1000
   * 
   * For instance setting the value to 500KB is equivalent to 500000 bytes.
   * 
   * The Linux utility RLIMIT_AS is used for limiting virtual memory. This is analagous to RAM,
   * but
   * less RAM will be utilized than the value specified. Typically this is most useful when
   * limiting
   * RAM usage of applications in a shared server environment.
   */
  getMaxMemoryUsage : function() 
  {
      var tmp = hoot.get('max.memory.usage');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return "-1"; 
  },

  /**
   * Spacing in meters used by the MaximalSublineMatcher during point discretization performed
   * between
   * matching ways.  Larger values may increase runtime performance but decrease conflation
   * quality.
   */
  getMaximalSublineSpacing : function() 
  {
      var tmp = hoot.get('maximal.subline.spacing');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 2.0; 
  },

  /**
   * When merging nodes during convert, determines what tolerance should be used for deciding two
   * nodes
   * are identical. Units in meters and defaults to 1.0m.
   * 
   * [[merger.creators]]
   */
  getMergeNearbyNodesDistance : function() 
  {
      var tmp = hoot.get('merge.nearby.nodes.distance');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 1.0; 
  },

  /**
   * List of merger creators to use during conflation. This can modify what features will be
   * conflated
   * (e.g. buildings, roads, etc.).  The ordering must match that in match.creators.
   * 'hoot info --mergers' displays information about the available mergers.
   */
  getMergerCreators : function() 
  {
      var tmp = hoot.get('merger.creators');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return "hoot::BuildingMergerCreator;hoot::ScriptMergerCreator;hoot::HighwayMergerCreator;hoot::ScriptMergerCreator;hoot::PoiPolygonMergerCreator;hoot::ScriptMergerCreator;hoot::ScriptMergerCreator;hoot::ScriptMergerCreator"; 
  },

  /**
   * A larger value will conflate more aggressively (fewer reviews) when using network
   * conflation. Users
   * may want to consider changing this value. Reasonable range is [1, ~10].
   */
  getNetworkConflictsAggression : function() 
  {
      var tmp = hoot.get('network.conflicts.aggression');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 8.8; 
  },

  /**
   * Added to a conflicting match score to allow for match pruning
   */
  getNetworkConflictsConflictingScoreThresholdModifier : function() 
  {
      var tmp = hoot.get('network.conflicts.conflicting.score.threshold.modifier');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 0.3; 
  },

  /**
   * The score threshold used to compare whole networks with the ConflictsNetworkMatcher
   */
  getNetworkConflictsMatcherThreshold : function() 
  {
      var tmp = hoot.get('network.conflicts.matcher.threshold');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 0.35; 
  },

  /**
   * A value of 0 will cause an edge to contribute (1 * score * weight) to each neighbor when
   * using
   * network conflation. A value of 1 will give approx (1 / n * score * weight) influence to each
   * neighbor.  This value is generally not changed by users.  Reasonable range is [0, 2].
   */
  getNetworkConflictsOutboundWeighting : function() 
  {
      var tmp = hoot.get('network.conflicts.outbound.weighting');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 0.25; 
  },

  /**
   * A larger value will increase the weight of partial matches when using network conflation.  A
   * smaller value prefers whole matches over partial matches. This value is generally not
   * changed by
   * users. Reasonable range is (0, ~2].
   */
  getNetworkConflictsPartialHandicap : function() 
  {
      var tmp = hoot.get('network.conflicts.partial.handicap');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 0.2; 
  },

  /**
   * Minimum separation distance, in meters, for match distance separation to use when sanity
   * checking
   * match relationships.
   */
  getNetworkConflictsSanityCheckMinSeparationDistance : function() 
  {
      var tmp = hoot.get('network.conflicts.sanity.check.min.separation.distance');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 5.0; 
  },

  /**
   * Distance multiplier to use when santiy checking match relationships.
   */
  getNetworkConflictsSanityCheckSeparationDistanceMultiplier : function() 
  {
      var tmp = hoot.get('network.conflicts.sanity.check.separation.distance.multiplier');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 2.5; 
  },

  /**
   * A larger value will increase the weight of stubs when using network conflation. This value
   * is
   * generally not changed by users. Reasonable range is (0, ~2].
   */
  getNetworkConflictsStubHandicap : function() 
  {
      var tmp = hoot.get('network.conflicts.stub.handicap');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 1.7; 
  },

  /**
   * A value of 0 will cause edges that are connected by a stub to contribute directly as
   * neighbors when
   * using network conflation.  Higher values will reduce that contribution.  This value is
   * generally
   * not changed by users.  Reasonable range is [0, ~10].
   */
  getNetworkConflictsStubThroughWeighting : function() 
  {
      var tmp = hoot.get('network.conflicts.stub.through.weighting');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 0.5; 
  },

  /**
   * A value of 0 will cause all edges to have the same weight with each neighbor, a higher value
   * will
   * give matches with more support a higher weight when using network conflation. This value is
   * generally not changed by users. Reasonable range is [0, 2].
   */
  getNetworkConflictsWeightInfluence : function() 
  {
      var tmp = hoot.get('network.conflicts.weight.influence');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 0.68; 
  },

  /**
   * The maximum number of optimization iterations used to calculate edge match sets.
   */
  getNetworkEdgeMatchSetFinderMaxIterations : function() 
  {
      var tmp = hoot.get('network.edge.match.set.finder.max.iterations');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 20; 
  },

  /**
   * X value curve midpoint value for the logistic function applied to conflation matches with
   * the
   * Network Algorithm. This value is generally not changed by users.
   */
  getNetworkMatchScoringFunctionCurveMidX : function() 
  {
      var tmp = hoot.get('network.match.scoring.function.curve.mid.x');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 0.5; 
  },

  /**
   * Curve steepness value for the logistic function applied to conflation matches with the
   * Network
   * Algorithm. This value is generally not changed by users.
   */
  getNetworkMatchScoringFunctionCurveSteepness : function() 
  {
      var tmp = hoot.get('network.match.scoring.function.curve.steepness');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 2.0; 
  },

  /**
   * Maximum possible value for the logistic function applied to conflation matches with the
   * Network
   * Algorithm. This value is generally not changed by users.
   */
  getNetworkMatchScoringFunctionMax : function() 
  {
      var tmp = hoot.get('network.match.scoring.function.max');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 1.0; 
  },

  /**
   * The threshold at which a network match is called a match when using network conflation.
   * 
   * See also:
   * 
   *  * _Estimate Pairwise Relationships_, <<hootalgo>>
   */
  getNetworkMatchThreshold : function() 
  {
      var tmp = hoot.get('network.match.threshold');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 0.15; 
  },

  /**
   * An internal option for manipulating the way network matching occurs. This should only be
   * used for
   * debug and test. The parameter must be a class that is registered with the factory and
   * subclasses
   * `NetworkMatcher`.
   */
  getNetworkMatcher : function() 
  {
      var tmp = hoot.get('network.matcher');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return "hoot::ConflictsNetworkMatcher"; 
  },

  /**
   * The maximum allowable length of a stub connection (way to node match) when using network
   * conflation.
   * Value in meters.
   */
  getNetworkMaxStubLength : function() 
  {
      var tmp = hoot.get('network.max.stub.length');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 20.0; 
  },

  /**
   * The minimum network match overlap percentage allowed for a network merge to occur.
   */
  getNetworkMergerMinLargeMatchOverlapPercentage : function() 
  {
      var tmp = hoot.get('network.merger.min.large.match.overlap.percentage');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 80.0; 
  },

  /**
   * The threshold at which a network miss is called a miss.
   * 
   * See also:
   * 
   *  * _Estimate Pairwise Relationships_, <<hootalgo>>
   */
  getNetworkMissThreshold : function() 
  {
      var tmp = hoot.get('network.miss.threshold');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 0.85; 
  },

  /**
   * The number of optimization iterations the network match creator will run when performing
   * network
   * conflation.
   */
  getNetworkOptimizationIterations : function() 
  {
      var tmp = hoot.get('network.optimization.iterations');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 10; 
  },

  /**
   * The threshold at which a network review is called a review. Reviews are also declared in
   * some
   * other situations when the relationship is not clear.
   * 
   * See also:
   * 
   *  * _Estimate Pairwise Relationships_, <<hootalgo>>
   */
  getNetworkReviewThreshold : function() 
  {
      var tmp = hoot.get('network.review.threshold');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 0.5; 
  },

  /**
   * The number of decimal places taken into account when comparing node circular error values.
   * Used by
   * node hash calculation.
   */
  getNodeComparisonCircularErrorSensitivity : function() 
  {
      var tmp = hoot.get('node.comparison.circular.error.sensitivity');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 6; 
  },

  /**
   * The number of decimal places taken into account when comparing node coordinates.  Used by
   * node
   * hash calculation.
   */
  getNodeComparisonCoordinateSensitivity : function() 
  {
      var tmp = hoot.get('node.comparison.coordinate.sensitivity');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 7; 
  },

  /**
   * The distance moved along a way, in meters, before calculating the outbound heading for a
   * node on
   * that way by the NodeMatcher.
   */
  getNodeMatcherAngleCalcDelta : function() 
  {
      var tmp = hoot.get('node.matcher.angle.calc.delta');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 0.001; 
  },

  /**
   * If false, the NodeMatcher will allow angle calculation if any situations are found where it
   * is
   * passed a node which is not at the beginning or end of a way.  If true, it will fail in the
   * aforementioned situation.
   */
  getNodeMatcherFailOnBadAngleSpots : function() 
  {
      var tmp = hoot.get('node.matcher.fail.on.bad.angle.spots');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * Determines how strictly the angle should be considered when calculating intersection tie
   * points for
   * rubber sheeting. A value of 0 will ignore angle entirely. Large will make the angle
   * comparison more
   * strict.
   */
  getNodeMatcherStrictness : function() 
  {
      var tmp = hoot.get('node.matcher.strictness');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 2; 
  },

  /**
   * If true, translation files will add a UUID to features.
   */
  getOgrAddUuid : function() 
  {
      var tmp = hoot.get('ogr.add.uuid');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return true; 
  },

  /**
   * If the OGR output file/layer exists when exporting, append the data instead of trying to
   * create a
   * new file/layer.
   */
  getOgrAppendData : function() 
  {
      var tmp = hoot.get('ogr.append.data');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * Debugging: Add the FCODE as the OSM source:fcode tag during translation.
   */
  getOgrDebugAddfcode : function() 
  {
      var tmp = hoot.get('ogr.debug.addfcode');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * Debugging: Print out Attributes and OSM Tag values during translation. For each feature,
   * this will
   * show what keys and values go into the translation and what the translated output is.
   */
  getOgrDebugDumptags : function() 
  {
      var tmp = hoot.get('ogr.debug.dumptags');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * Debugging: Print out which attributes are dropped during export validation.
   */
  getOgrDebugDumpvalidate : function() 
  {
      var tmp = hoot.get('ogr.debug.dumpvalidate');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * Debugging: When building internal lookup tables, print values that clash.
   */
  getOgrDebugLookupclash : function() 
  {
      var tmp = hoot.get('ogr.debug.lookupclash');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * Debugging: Print the columns that are not matched during one2one translation. This will show
   * all
   * Attribute columns and values that do not match a one2one rule.
   */
  getOgrDebugLookupcolumn : function() 
  {
      var tmp = hoot.get('ogr.debug.lookupcolumn');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * Add the ESRI specific FCSUBTYPE field to the output.
   */
  getOgrEsriFcsubtype : function() 
  {
      var tmp = hoot.get('ogr.esri.fcsubtype');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return true; 
  },

  /**
   * The name to use for the ESRI Feature Dataset on export. Note: This only applies to ESRI File
   * Geodatabases.
   */
  getOgrEsriFdname : function() 
  {
      var tmp = hoot.get('ogr.esri.fdname');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return "TDS"; 
  },

  /**
   * The regexp to be used to filter the layer names when importing layers from an ESRI File
   * Geodatabase. The default is to import all layers from a FGDB.  Setting this variable will
   * override the filter value that can be set by the layerNameFilter function inside a
   * translation
   * script.
   */
  getOgrImportFilter : function() 
  {
      var tmp = hoot.get('ogr.import.filter');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return ""; 
  },

  /**
   * When exporting to TDSv40 and TDSv61:
   * - "attribute" Add unused tags to the "ZI006_MEM" field.
   * - "file" Save the unused tags in a new layer (extra_[PLA]).
   * - "none" Don't save the unused tags, just drop them.
   * 
   * When exporting to MGCP:
   * - "attribute" Add unused tags to the "TXT" field.
   * - "file" Save the unused tags in a new layer (extra_[PLA]).
   * - "none" Don't save the unused tags, just drop them.
   * 
   * NOTE: According to the MGCP and Shapefile specifications, the "TXT" field has a maximum
   * length of
   * 255 characters. Extra text will be truncated.
   */
  getOgrNoteExtra : function() 
  {
      var tmp = hoot.get('ogr.note.extra');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return "attribute"; 
  },

  /**
   * If specified the OGR reader will limit data read from the data source to only features that
   * intersect the given bounding box. The format is "minx,miny,maxx,maxy" specified in the
   * projection
   * of the input data source.
   * 
   * The method OGRLayer::SetSpatialFilterRect is used to limit the bounding box. Some formats
   * will
   * intelligently use indexes, others will simply filter features after reading from the data
   * source.
   * 
   * Example Usage:
   * 
   * ----
   * hoot convert -D ogr.reader.bounding.box=106.851,-6.160,107.052,-5.913 test-
   * files/jakarta_raya_coastline.shp output.osm --trans translations/Identity.js
   * ----
   */
  getOgrReaderBoundingBox : function() 
  {
      var tmp = hoot.get('ogr.reader.bounding.box');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return ""; 
  },

  /**
   * Similar to `ogr.reader.bounding.box` but uses WGS84 to specify the bounds rather than the
   * source
   * projection. Only one of the two options can be specified.
   * 
   * A best effort will be made to convert between the two projections. The translated bounding
   * box
   * will approximate the minimum bounding rectangle of the lat/lng bounding box. In some cases
   * this
   * may be significantly larger.
   */
  getOgrReaderBoundingBoxLatlng : function() 
  {
      var tmp = hoot.get('ogr.reader.bounding.box.latlng');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return ""; 
  },

  /**
   * From the GDAL docs:
   * If YES, the detected X,Y,Z or geometry columns will be stored as regular attribute fields.
   */
  getOgrReaderCsvKeepGeomFields : function() 
  {
      var tmp = hoot.get('ogr.reader.csv.keep.geom.fields');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return "NO"; 
  },

  /**
   * From the GDAL docs:
   * A comma separated list of possible names for Y/latitude coordinate of a point. Each name
   * might be a
   * pattern using the star character in starting and/or ending position. E.g.: prefix*, *suffix
   * or
   * *middle*. The values in the column must be floating point values.
   */
  getOgrReaderCsvLatfield : function() 
  {
      var tmp = hoot.get('ogr.reader.csv.latfield');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return "Lat*,lat*,LAT*"; 
  },

  /**
   * From the GDAL docs:
   * A comma separated list of possible names for X/longitude coordinate of a point. Each name
   * might be
   * a pattern using the star character in starting and/or ending position. E.g.: prefix*,
   * *suffix or
   * *middle*. The values in the column must be floating point values.
   * 
   * 
   * 
   * be a pattern using the star character in starting and/or ending position. E.g.: prefix*,
   * *suffix
   * or *middle*. The values in the column must be floating point values.
   */
  getOgrReaderCsvLonfield : function() 
  {
      var tmp = hoot.get('ogr.reader.csv.lonfield');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return "Lon*,lon*,LON*"; 
  },

  /**
   * If specified the OGR reader will override the reported projection with the specified EPSG
   * code. If
   * the value is < 0 then the projection reported by the source data set will be used. In most
   * cases
   * the default value is fine.
   * 
   * This can sometimes be necessary when reading from a DB created with osm2pgsql. E.g.
   * 
   * ----
   * hoot convert -D ogr.reader.epsg.override=900913 PG:"dbname='gis' host='localhost'
   * port='5432' user='hoot' password='blahblah'" tmp/output.shp
   * ----
   */
  getOgrReaderEpsgOverride : function() 
  {
      var tmp = hoot.get('ogr.reader.epsg.override');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return -1; 
  },

  /**
   * If set, the ogr reader will use the value at the specified field to populate node IDs.
   */
  getOgrReaderNodeIdFieldName : function() 
  {
      var tmp = hoot.get('ogr.reader.node.id.field.name');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return ""; 
  },

  /**
   * GDAL Option: When reading OGDI datasources (VPF etc), setting this to 'yes' causes the layer
   * names to be simplified.
   * For example : watrcrsl_hydro instead of 'watrcrsl@hydro(*)_line'
   */
  getOgrReaderOgdiLaunderLayerNames : function() 
  {
      var tmp = hoot.get('ogr.reader.ogdi.launder.layer.names');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return "yes"; 
  },

  /**
   * If the list of o2s tags is > 255 char, split it into into 254 char long pieces. If this is
   * false,
   * it will be exported as one big string.
   */
  getOgrSplitO2s : function() 
  {
      var tmp = hoot.get('ogr.split.o2s');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * Turn OGR related errors into warnings or turn them off. Valid values are: on, off, warn
   */
  getOgrStrictChecking : function() 
  {
      var tmp = hoot.get('ogr.strict.checking');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return "on"; 
  },

  /**
   * Add the eLTDS specific attributes (SCAMIN, SCAMAX, LINK_ID) to the output.
   */
  getOgrTdsAddEtds : function() 
  {
      var tmp = hoot.get('ogr.tds.add.etds');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return true; 
  },

  /**
   * When exporting to TDSv40 and TDSv61:
   * - "note" Add unused tags to the "ZI006_MEM" field.
   * - "file" Save the unused tags in a new layer (extra_[PLA]).
   * - "none" Don't save the unused tags, just drop them.
   * 
   * NOTE: If exporting to Shapefile, this field will be truncated to 255 characters.
   */
  getOgrTdsExtra : function() 
  {
      var tmp = hoot.get('ogr.tds.extra');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return "note"; 
  },

  /**
   * Where applicable, export data in Thematic Groups (TransportationGroundCrv, StructurePnt etc)
   * instead of one FCODE per file/layer (ROAD_L, BUILDING_P etc).
   */
  getOgrThematicStructure : function() 
  {
      var tmp = hoot.get('ogr.thematic.structure');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return true; 
  },

  /**
   * For the schema switcher, throw errors instead of returning a partial translation/o2s_X
   * feature
   * from a translation.
   */
  getOgrThrowError : function() 
  {
      var tmp = hoot.get('ogr.throw.error');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * Create all layers when using the OGR writer whether or not the layers contain features.
   * Setting
   * this to true can be useful when conforming to strict specifications.
   */
  getOgrWriterCreateAllLayers : function() 
  {
      var tmp = hoot.get('ogr.writer.create.all.layers');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * TODO: description
   */
  getOgrWriterPreLayerName : function() 
  {
      var tmp = hoot.get('ogr.writer.pre.layer.name');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return ""; 
  },

  /**
   * Set the script to use with OGR writer. For example:
   * 
   * ----
   * hoot convert \
   *   -D ogr.writer.script=test-files/io/SampleTranslation.js \
   *   -D ogr.writer.pre.layer.name=bar \
   *   test-files/io/SampleTranslation.osm \
   *   PG:"dbname='osm_gis2' host='localhost' port='5432' user='hoot' password='hoottest'"
   * ----
   */
  getOgrWriterScript : function() 
  {
      var tmp = hoot.get('ogr.writer.script');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return ""; 
  },

  /**
   * Merges nearby nodes together when converting from an OGR format to OSM.
   */
  getOgr2osmMergeNearbyNodes : function() 
  {
      var tmp = hoot.get('ogr2osm.merge.nearby.nodes');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return true; 
  },

  /**
   * Implicitly merges certain individual building parts into a single part when converting from
   * an OGR
   * format to OSM.
   */
  getOgr2osmSimplifyComplexBuildings : function() 
  {
      var tmp = hoot.get('ogr2osm.simplify.complex.buildings');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return true; 
  },

  /**
   * Add a tag with the bounding box for each element
   */
  getOsmAddBboxTag : function() 
  {
      var tmp = hoot.get('osm.add.bbox.tag');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * Specifies the reader that the OsmMapReaderFactory will use. This overrides any information
   * derived
   * from the URL.
   */
  getOsmMapReaderFactoryReader : function() 
  {
      var tmp = hoot.get('osm.map.reader.factory.reader');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return ""; 
  },

  /**
   * By default, OsmXmlReader will not add child references (node ref, elements members) to
   * parent
   * elements if those elements are not present in the data.  For external sorting and
   * translations,
   * where partial chunks of elements will be present the setting is changed.
   */
  getOsmMapReaderXmlAddChildRefsWhenMissing : function() 
  {
      var tmp = hoot.get('osm.map.reader.xml.add.child.refs.when.missing');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * Specifies the writer that the OsmMapWriterFactory will use. This overrides any information
   * derived
   * from the URL.
   */
  getOsmMapWriterFactoryWriter : function() 
  {
      var tmp = hoot.get('osm.map.writer.factory.writer');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return ""; 
  },

  /**
   * Turns on autoformatting (line breaks, indentation etc) for XML output.
   */
  getOsmMapWriterFormatXml : function() 
  {
      var tmp = hoot.get('osm.map.writer.format.xml');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return true; 
  },

  /**
   * Sets the value for a "schema" attribute when writing a map to OSM XML.  NOTE: this will only
   * be
   * written if the value is not empty.
   */
  getOsmMapWriterSchema : function() 
  {
      var tmp = hoot.get('osm.map.writer.schema');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return ""; 
  },

  /**
   * If true, the OSM map writer will NOT write a file if the map is empty.
   * The default is to write a file even if the map is empty.
   */
  getOsmMapWriterSkipEmptyMap : function() 
  {
      var tmp = hoot.get('osm.map.writer.skip.empty.map');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * If true, the OSM API database writer drops the database constraints before writing the data
   * and
   * re-enables them after the writing is complete.  This can only be used with databases that
   * have been
   * taken offline from other users.
   */
  getOsmapidbBulkInserterDisableDatabaseConstraintsDuringWrite : function() 
  {
      var tmp = hoot.get('osmapidb.bulk.inserter.disable.database.constraints.during.write');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * If true, the OSM API database writer drops the database indexes before writing the data and
   * re-enables them after the writing is complete.  This can only be used with databases that
   * have been
   * taken offline from other users.
   */
  getOsmapidbBulkInserterDisableDatabaseIndexesDuringWrite : function() 
  {
      var tmp = hoot.get('osmapidb.bulk.inserter.disable.database.indexes.during.write');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * If true, the OSM API database writer will update the database to reserve the range of record
   * IDs
   * parsed from the input data *before* writing the data to output.  IMPORTANT:  This option
   * should
   * always be enabled in online environments (other writers present).  If it is not enabled in
   * online
   * environments, the risk of record ID conflicts will be present in the database.  The output
   * destination must be an OSM API database or this setting will always be treated as being
   * "false".
   * If the output destination is a SQL file, the SQL statements to update the record IDs will be
   * written to the SQL output for later execution.
   */
  getOsmapidbBulkInserterReserveRecordIdsBeforeWritingData : function() 
  {
      var tmp = hoot.get('osmapidb.bulk.inserter.reserve.record.ids.before.writing.data');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * If true, the OSM API database bulk inserter write element ID sequence update SQL statements
   * when
   * the output is a SQL file.  If false, the ID update statements will not be written.
   */
  getOsmapidbBulkInserterWriteSqlFileIdSequenceUpdates : function() 
  {
      var tmp = hoot.get('osmapidb.bulk.inserter.write.sql.file.id.sequence.updates');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return true; 
  },

  /**
   * This is required when using either the OsmApiDbAwareHootApiDbReader or the
   * OsmApiDbAwareHootApiDbWriter It forces database reading/writing use the specified OSM API
   * database
   * as master for determining the sequencing of element ID's.
   */
  getOsmapidbIdAwareUrl : function() 
  {
      var tmp = hoot.get('osmapidb.id.aware.url');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return ""; 
  },

  /**
   * If true, the data is rubbersheeted before conflation, moving perturbed data closer to
   * reference data.
   */
  getPertyApplyRubberSheet : function() 
  {
      var tmp = hoot.get('perty.apply.rubber.sheet');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return true; 
  },

  /**
   * The PERTY D value. D is used in e ^ (-perty.grid.spacing / D). Defaults to 1000. Larger
   * values
   * result in a more correlated permutation grid.
   */
  getPertyCsmD : function() 
  {
      var tmp = hoot.get('perty.csm.D');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 1000; 
  },

  /**
   * The number of duplicate POIs is set as `round(abs(N(0, sigma^2))) + 1`. Setting sigma to 0
   * will
   * guarantee that there will always be exactly one duplicate.
   */
  getPertyDuplicatePoiDuplicateSigma : function() 
  {
      var tmp = hoot.get('perty.duplicate.poi.duplicate.sigma');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 1.0; 
  },

  /**
   * The distance that a feature is moved is based on the circular error of the source point. The
   * new point will be put within N(0, sigma^2) * moveMultiplier meters of the source point where
   * sigma is the standard deviation associated with the source point.
   */
  getPertyDuplicatePoiMoveMultiplier : function() 
  {
      var tmp = hoot.get('perty.duplicate.poi.move.multiplier');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 1.0; 
  },

  /**
   * The probability of at least one duplicate being created. See setDuplicateSigma to determine
   * how many duplicates will be created.
   */
  getPertyDuplicatePoiProbability : function() 
  {
      var tmp = hoot.get('perty.duplicate.poi.probability');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 0.10; 
  },

  /**
   * The size of the PERTY grid spacing in meters.
   */
  getPertyGridSpacing : function() 
  {
      var tmp = hoot.get('perty.grid.spacing');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 100; 
  },

  /**
   * The probability of a change to each character in the name. The expected number of changes is
   * `perty.name.change.probability` * str.size().
   */
  getPertyNameChangeProbability : function() 
  {
      var tmp = hoot.get('perty.name.change.probability');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 0.05; 
  },

  /**
   * The probability that a name will be modified.
   */
  getPertyNameProbability : function() 
  {
      var tmp = hoot.get('perty.name.probability');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 0.05; 
  },

  /**
   * A list of operations that should be applied after the geometries have been shifted by PERTY.
   * 'hoot info --operators | grep Perty' displays information about the available operations.
   */
  getPertyOps : function() 
  {
      var tmp = hoot.get('perty.ops');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return "hoot::PertyWaySplitVisitor;hoot::PertyWayGeneralizeVisitor;hoot::PertyRemoveRandomElementVisitor;hoot::PertyDuplicatePoiOp;hoot::PertyRemoveTagVisitor;hoot::PertyNameVisitor"; 
  },

  /**
   * The sigma rx parameter for PERTY (random error in X). This is only relevant when
   * perty.algorithm
   * is set to FullCovariance.
   */
  getPertyRandomErrorX : function() 
  {
      var tmp = hoot.get('perty.random.error.x');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 0; 
  },

  /**
   * The sigma ry parameter for PERTY (random error in Y). This is only relevant when
   * perty.algorithm
   * is set to FullCovariance.
   */
  getPertyRandomErrorY : function() 
  {
      var tmp = hoot.get('perty.random.error.y');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 0; 
  },

  /**
   * The probability that a feature will be removed.
   */
  getPertyRemoveRandomProbability : function() 
  {
      var tmp = hoot.get('perty.remove.random.probability');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 0.05; 
  },

  /**
   * Set the probability that a tag will be removed.
   */
  getPertyRemoveTagProbability : function() 
  {
      var tmp = hoot.get('perty.remove.tag.probability');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 0.05; 
  },

  /**
   * A list of tag keys which are exempt from the tag removal done by PertyRemoveTagsVisitor.
   * This is
   * useful for preventing the removal of tags Hootenanny relies on during conflation.
   */
  getPertyRemoveTagVisitorExemptTagKeys : function() 
  {
      var tmp = hoot.get('perty.remove.tag.visitor.exempt.tag.keys');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return "REF1;REF2;hoot:status;uuid"; 
  },

  /**
   * A list of tag keys which, rather than being removed by the PertyRemoveTagVisitor, will have
   * their
   * values replaced instead.  The tag keys in the list match one to one with the replacement
   * values in
   * perty.remove.tag.visitor.subsitution.values.
   */
  getPertyRemoveTagVisitorSubstitutionKeys : function() 
  {
      var tmp = hoot.get('perty.remove.tag.visitor.substitution.keys');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return "highway"; 
  },

  /**
   * A list of tag values which, should be substituted by PertyRemoveTagVisitor.  The tag values
   * in the
   * list match one to one with the replacement values in
   * perty.remove.tag.visitor.subsitution.keys.
   */
  getPertyRemoveTagVisitorSubstitutionValues : function() 
  {
      var tmp = hoot.get('perty.remove.tag.visitor.substitution.values');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return "road"; 
  },

  /**
   * Distance parameter (in meters) that determines how far out to search when trying to match
   * features
   * during conflation of reference and perturbed datasets.  This is equivalent in nature to the
   * 'error:circular' tag used in Hootenanny conflation, however this setting is used instead for
   * PERTY scoring only.
   */
  getPertySearchDistance : function() 
  {
      var tmp = hoot.get('perty.search.distance');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 15; 
  },

  /**
   * A random seed integer passed to the random number generator accessed by PERTY to give
   * consistent
   * results over multiple runs. A value of -1 will generate a seed based on the time to provide
   * pseudo-random results in the output.  Other seed values will yield repeatable results when
   * the
   * same seed is used in consecutive calls to the PERTY related commands.
   */
  getPertySeed : function() 
  {
      var tmp = hoot.get('perty.seed');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return -1; 
  },

  /**
   * The sigma sx parameter for PERTY. This controls how much correlated error in the
   * X direction is in the output permutation. Units in meters.
   */
  getPertySystematicErrorX : function() 
  {
      var tmp = hoot.get('perty.systematic.error.x');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 50; 
  },

  /**
   * The sigma sy parameter for PERTY. This controls how much correlated error in the
   * Y direction is in the output permutation. Units in meters.
   */
  getPertySystematicErrorY : function() 
  {
      var tmp = hoot.get('perty.systematic.error.y');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 50; 
  },

  /**
   * A score variance in the range of 0.0 to 1.0 by which a `perty-test` test run score may vary
   * while still allowing the test run's status to be described as passing.  Test run score
   * differences
   * larger than this value will cause the test run's status to be described as failing.  If you
   * are
   * not sure what your expected scores should be and want to bypass this check, create a list
   * with
   * all entries equal to "1.0" of the same size as perty.test.num.runs, and then
   * set perty.test.allowed.score.variance to "1.0".  This effectively disables the score
   * validation.
   */
  getPertyTestAllowedScoreVariance : function() 
  {
      var tmp = hoot.get('perty.test.allowed.score.variance');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 0.025; 
  },

  /**
   * Amount by which the dynamic input variables specified in perty.test.dynamic.variables are
   * incremented during each test run by perty-test.
   */
  getPertyTestDynamicVariableIncrement : function() 
  {
      var tmp = hoot.get('perty.test.dynamic.variable.increment');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 0.1; 
  },

  /**
   * Dynamic variable value initially assigned to a PERTY test dynamic variable when executed by
   * `perty-test`.
   */
  getPertyTestDynamicVariableStartValue : function() 
  {
      var tmp = hoot.get('perty.test.dynamic.variable.start.value');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 0; 
  },

  /**
   * A list of one or more numeric PERTY variables to be assigned a start value (specified in
   * perty.test.dynamic.variable.start.value) and then incremented once per test run by
   * `perty-test` (specified in perty.test.dynamic.variable.increment) to the value of.  The list
   * is
   * restricted to Hootenanny PERTY options only (perty.*) of a numeric type.
   */
  getPertyTestDynamicVariables : function() 
  {
      var tmp = hoot.get('perty.test.dynamic.variables');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return ""; 
  },

  /**
   * A list of expected PERTY scores in the range of 0.0 to 1.0 for a `perty-test` run.  The
   * number of
   * scores must match the value assigned to perty.test.num.runs.  If you are not sure what your
   * expected scores should be and want to bypass this check, create a list with all entries
   * equal
   * to "1.0" of the same size as perty.test.num.runs, and then set
   * perty.test.allowed.score.variance
   * to "1.0".  This effectively disables the score validation.
   */
  getPertyTestExpectedScores : function() 
  {
      var tmp = hoot.get('perty.test.expected.scores');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return "1.0"; 
  },

  /**
   * If true, the `perty-test` will mark a test as failing if its test run score is higher than
   * the
   * expected score and outside of the allowable score variance; if false, will always allow
   * higher
   * test run scores to result in a passing test run, despite being outside of the allowable
   * score
   * variance.
   */
  getPertyTestFailOnBetterScore : function() 
  {
      var tmp = hoot.get('perty.test.fail.on.better.score');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * If true, Hootenanny map statistics files are output for all PERTY outputs created by `perty-
   * test`.
   */
  getPertyTestGenerateMapStats : function() 
  {
      var tmp = hoot.get('perty.test.generate.map.stats');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * The number of test runs executed by `perty-test`.  A single input variable, or multiple
   * variables
   * (specified in perty.test.dynamic.variable) assigned identical starting values (specified in
   * perty.test.dynamic.variable.start.value), is/are altered by an increment during each test
   * (specified in perty.test.dynamic.variable.increment).
   */
  getPertyTestNumRuns : function() 
  {
      var tmp = hoot.get('perty.test.num.runs');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 1; 
  },

  /**
   * The number of simulations per test run executed by `perty-test`.  A test run is made up of
   * multiple simulations.  Scores all simulation executed by the test run are averaged to give
   * the
   * final PERTY score for the test run.
   */
  getPertyTestNumSimulations : function() 
  {
      var tmp = hoot.get('perty.test.num.simulations');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 3; 
  },

  /**
   * Distance parameter, in meters, that determines to what degree a way is generalized by PERTY.
   * Higher values result in more generalization (more nodes removed).
   */
  getPertyWayGeneralizeEpsilon : function() 
  {
      var tmp = hoot.get('perty.way.generalize.epsilon');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 1; 
  },

  /**
   * The probability between 0.0 and 1.0 that a way will be generalized by PERTY.
   */
  getPertyWayGeneralizeProbability : function() 
  {
      var tmp = hoot.get('perty.way.generalize.probability');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 0.1; 
  },

  /**
   * The minimum spacing, in meters, that may occur between nodes created by PERTY way splits.
   */
  getPertyWaySplitMinNodeSpacing : function() 
  {
      var tmp = hoot.get('perty.way.split.min.node.spacing');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 1; 
  },

  /**
   * The probability between 0.0 and 1.0 that a way will be split into multiple features by
   * PERTY.
   */
  getPertyWaySplitProbability : function() 
  {
      var tmp = hoot.get('perty.way.split.probability');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 0.1; 
  },

  /**
   * By default, conflation examines all tags with keys containing the text "phone" for phone
   * number
   * comparisons.  You can expand the tag keys searched by populating this list. From the command
   * line,
   * separate list items with a semicolon and surround the entire list in double quotes.
   */
  getPhoneNumberAdditionalTagKeys : function() 
  {
      var tmp = hoot.get('phone.number.additional.tag.keys');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return ""; 
  },

  /**
   * The phone number format used when normalizing phone numbers.  Valid values are: E164,
   * INTERNATIONAL,
   * NATIONAL, and RFC3966.
   */
  getPhoneNumberNormalizationFormat : function() 
  {
      var tmp = hoot.get('phone.number.normalization.format');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return "NATIONAL"; 
  },

  /**
   * Optional geographical region code used when comparing phone numbers.   See:
   * http://www.unicode.org/cldr/charts/30/supplemental/territory_information.html  Specifying a
   * region
   * code, if known for the input data, may increase phone number matching accuracy but may also
   * have
   * runtime performance implications.
   */
  getPhoneNumberRegionCode : function() 
  {
      var tmp = hoot.get('phone.number.region.code');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return "US"; 
  },

  /**
   * If true, POI/Polygon conflation will attempt to search for phone numbers within tag value
   * text
   * that may contain things other than phone numbers.  If false, the conflation will assume the
   * tag
   * value is a phone number and will not search within it.  poi.polygon.phone.number.region.code
   * must
   * be set to a valid region code when enabling this option.  Enabling this option may have
   * runtime
   * performance implications.
   */
  getPhoneNumberSearchInText : function() 
  {
      var tmp = hoot.get('phone.number.search.in.text');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * A list of scripts to include before loading the user's plugin script. The path will be
   * search as:
   * current directory (CWD), $CWD/rules, $HOOT_HOME/rules.
   */
  getPluginContextIncludes : function() 
  {
      var tmp = hoot.get('plugin.context.includes');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return "HootLib.js"; 
  },

  /**
   * If true, POI to POI conflation will ignore the types of the features being compared
   * completely as
   * long as those being compared have a populated name field.
   */
  getPoiIgnoreTypeIfNamePresent : function() 
  {
      var tmp = hoot.get('poi.ignore.type.if.name.present');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * The threshold at which a match is called a match for POIs.
   * 
   * See also:
   * 
   *  * _Estimate Pairwise Relationships_, <<hootalgo>>
   */
  getPoiMatchThreshold : function() 
  {
      var tmp = hoot.get('poi.match.threshold');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${conflate.match.threshold.default}"); 
  },

  /**
   * The threshold at which a miss is called a miss for POIs.
   * 
   * See also:
   * 
   *  * _Estimate Pairwise Relationships_, <<hootalgo>>
   */
  getPoiMissThreshold : function() 
  {
      var tmp = hoot.get('poi.miss.threshold');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${conflate.miss.threshold.default}"); 
  },

  /**
   * If true, POI/Polygon conflation will allow house number subletter mismatches for the
   * addresses with
   * the same house number.  e.g. when enabled, 23a Elm Street matches 23 Elm Street
   */
  getPoiPolygonAddressAllowLenientHouseNumberMatching : function() 
  {
      var tmp = hoot.get('poi.polygon.address.allow.lenient.house.number.matching');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return true; 
  },

  /**
   * If true, POI/Polygon conflation will compare addresses as one of the criteria for matching
   * features.
   * If the data being conflated is known to have poor address data, disabling this option may
   * speed up
   * conflation runtime performance.  This option is left turned off by default due to the small
   * startup
   * time required to use libpostal (~5s), which would be wasteful for small datasets known to
   * have no
   * addresses in them.  The startup time is incurred only once per Hootenanny command
   * invocation.
   */
  getPoiPolygonAddressMatchEnabled : function() 
  {
      var tmp = hoot.get('poi.polygon.address.match.enabled');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * If true, Hootenanny will attempt to translate to English the value of any tag that is part
   * of an
   * address before normalizing it (note that address normalization may involve some form of
   * language
   * translation even when this setting is ).  This can have significant impact on the runtime
   * performance of conflation when enabled and should only be enabled if the source data is
   * known to
   * have non-English addresses.  The configuration option, 'language.translation.translator',
   * controls
   * which translator is used.
   */
  getPoiPolygonAddressTranslateToEnglish : function() 
  {
      var tmp = hoot.get('poi.polygon.address.translate.to.english');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * If true, POI/Polygon conflation will use only libpostal for translating languages in
   * addresses,
   * which occurs during address normalization.  If false, and
   * poi.polygon.translate.addresses.to.english
   * is enabled, POI/Polygon conflation will use additional to English language translation
   * before
   * address normalization.  Disable this only if libpostal's language translation is not
   * adequate for
   * your language translation needs.
   */
  getPoiPolygonAddressUseDefaultLanguageTranslationOnly : function() 
  {
      var tmp = hoot.get('poi.polygon.address.use.default.language.translation.only');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return true; 
  },

  /**
   * If true, instances where multiple POIs were matched to a single polygon will result in all
   * of those
   * POIs being automatically merged into the polygon.  If false, then each matched POI will
   * generate a
   * review against the polygon instead.
   */
  getPoiPolygonAutoMergeManyPoiToOnePolyMatches : function() 
  {
      var tmp = hoot.get('poi.polygon.auto.merge.many.poi.to.one.poly.matches');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * If true, POI to Polygon conflation will not attempt to conflate two features with the same
   * source
   * tag value.  e.g. both have 'source=osm' tag  The source tag key is specified by
   * poi.polygon.source.tag.key.  How strictly the source tag key must be matched is controlled
   * by
   * poi.polygon.disable.same.source.conflation.match.tag.key.prefix.only.  This setting is
   * useful when
   * you have a data layer where data has been collected as both POIs and polygons for the same
   * source
   * and you never want the two source to be conflated together.
   */
  getPoiPolygonDisableSameSourceConflation : function() 
  {
      var tmp = hoot.get('poi.polygon.disable.same.source.conflation');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * If set to false and poi.polygon.disable.same.source.conflation is set to true, POI to
   * polygon
   * conflation will disable conflation only between features who have the exact same source tag
   * value.
   * e.g. both have 'source=osm' tag  If set to true and
   * poi.polygon.disable.same.source.conflation is
   * set to true, then the tag matcher is less strict and will attempt to match the prefix of the
   * source
   * tag value when delimited by a colon.  e.g. 'source=mgcp:buildp_clip;osm' will match
   * 'source=mgcp:builda_clip;osm' since both tag values begin with 'mgcp:'.
   */
  getPoiPolygonDisableSameSourceConflationMatchTagKeyPrefixOnly : function() 
  {
      var tmp = hoot.get('poi.polygon.disable.same.source.conflation.match.tag.key.prefix.only');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return true; 
  },

  /**
   * If true, POI to Polygon conflation will perform additional checks against surrounding
   * features
   * for match evidence.  This setting allows for detailed conflation customization but can be
   * runtime
   * expensive when enabled.
   */
  getPoiPolygonEnableAdvancedMatching : function() 
  {
      var tmp = hoot.get('poi.polygon.enable.advanced.matching');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * If true, POI to Polygon conflation will attempt to reduce unnecessary reviews without
   * increasing
   * incorrect matches.  This setting is somewhat experimental and can be runtime expensive when
   * enabled.
   */
  getPoiPolygonEnableReviewReduction : function() 
  {
      var tmp = hoot.get('poi.polygon.enable.review.reduction');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return true; 
  },

  /**
   * If this setting is true, POI to Polygon conflation will attempt to match the closest feature
   * pairs
   * only.  The conflation will not match additional features at greater distances, even if they
   * are
   * within the match distance threshold.  Multiple features matches are still possible in the
   * case of
   * exact distance ties.  If this setting is false, then multiple POIs found within the match
   * distance
   * threshold of a polygon are treated as reviews.
   */
  getPoiPolygonKeepClosestMatchesOnly : function() 
  {
      var tmp = hoot.get('poi.polygon.keep.closest.matches.only');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * The maximum distance, in meters, between a POI and a polygon where they can still be
   * considered
   * a match based on distance criteria only.
   */
  getPoiPolygonMatchDistanceThreshold : function() 
  {
      var tmp = hoot.get('poi.polygon.match.distance.threshold');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 5.0; 
  },

  /**
   * The minimum evidence score at which a POI will be matched to a polygon.  Valid values are 1
   * to 4.
   * If an evidence score for a feature pair falls below this value, the relationship between the
   * features will be classified as a review or miss, depending on the value of
   * 'poi.polygon.review.evidence.threshold'.  Generally, this setting should not be changed
   * except
   * when working with specific POI/Polygon conflation use cases that require it.
   */
  getPoiPolygonMatchEvidenceThreshold : function() 
  {
      var tmp = hoot.get('poi.polygon.match.evidence.threshold');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 3; 
  },

  /**
   * The threshold at which a match is called a match when comparing POIs to polygons.
   * 
   * See also:
   * 
   *  * _Estimate Pairwise Relationships_, <<hootalgo>>
   */
  getPoiPolygonMatchThreshold : function() 
  {
      var tmp = hoot.get('poi.polygon.match.threshold');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${conflate.match.threshold.default}"); 
  },

  /**
   * The threshold at which a miss is called a miss when comparing POIs to polygons.
   * 
   * See also:
   * 
   *  * _Estimate Pairwise Relationships_, <<hootalgo>>
   */
  getPoiPolygonMissThreshold : function() 
  {
      var tmp = hoot.get('poi.polygon.miss.threshold');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${conflate.miss.threshold.default}"); 
  },

  /**
   * The minimum similarity the name scores of two features can have and be considered a name
   * match, with 0.0 being the least similar and 1.0 being the most similar (-1.0 if there are no
   * names
   * present (null).
   */
  getPoiPolygonNameScoreThreshold : function() 
  {
      var tmp = hoot.get('poi.polygon.name.score.threshold');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 0.8; 
  },

  /**
   * If true, Hootenanny will attempt to translate to English the value of any name tag.  This
   * can have
   * significant impact on the runtime performance of conflation when enabled and should only be
   * enabled
   * if the source data is known to have non-English names.  The configuration option,
   * 'language.translation.translator', controls which translator is used.
   */
  getPoiPolygonNameTranslateToEnglish : function() 
  {
      var tmp = hoot.get('poi.polygon.name.translate.to.english');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * If true, POI/Polygon conflation will compare phone number as one of the criteria for
   * matching
   * features.  If the data being conflated is known to have poor telephone number data,
   * disabling this
   * option may speed up conflation runtime performance.
   */
  getPoiPolygonPhoneNumberMatchEnabled : function() 
  {
      var tmp = hoot.get('poi.polygon.phone.number.match.enabled');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return true; 
  },

  /**
   * Path to a file containing a list of POI feature ignore tags.  Any POIs containing tags in
   * the file
   * will be skipped by POI to Polygon conflation.
   */
  getPoiPolygonPoiIgnoreTagsFile : function() 
  {
      var tmp = hoot.get('poi.polygon.poi.ignore.tags.file');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${HOOT_HOME}/conf/core/poi-polygon/poiPolygonPoiTagIgnoreList"); 
  },

  /**
   * Path to a file containing a list of polygon feature ignore tags.  Any polygons containing
   * tags in
   * the file will be skipped by POI to Polygon conflation.
   */
  getPoiPolygonPolyIgnoreTagsFile : function() 
  {
      var tmp = hoot.get('poi.polygon.poly.ignore.tags.file');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${HOOT_HOME}/conf/core/poi-polygon/poiPolygonPolyTagIgnoreList"); 
  },

  /**
   * If true, debug match distance output will be obtained from manually matched source data and
   * printed
   * if running 'hoot score-matches' with POI to Polygon conflation.
   */
  getPoiPolygonPrintMatchDistanceTruth : function() 
  {
      var tmp = hoot.get('poi.polygon.print.match.distance.truth');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * If true, POI to polygon conflation will classify all points with OSM address tags as POIs
   * even if
   * they do not have specific type tags.
   */
  getPoiPolygonPromotePointsWithAddressesToPois : function() 
  {
      var tmp = hoot.get('poi.polygon.promote.points.with.addresses.to.pois');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * The maximum distance, in meters, combined with the circular error of the features being
   * compared,
   * the total of which allows the features to still be considered a match based on distance
   * criteria
   * only.
   */
  getPoiPolygonReviewDistanceThreshold : function() 
  {
      var tmp = hoot.get('poi.polygon.review.distance.threshold');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 125.0; 
  },

  /**
   * The minimum evidence score at which a POI will be reviewed against a polygon, if the
   * evidence score
   * does not meet the threshold defined by 'poi.polygon.match.evidence.threshold'.  Valid values
   * are
   * 0 to 3.  If an evidence score for a feature pair falls below this value, the relationship
   * between
   * the features will be classified as a miss.  If the value is set to 0, all feature pairs
   * which did
   * not match will be reviewed.  If the value is set greater than or equal to
   * 'poi.polygon.match.evidence.threshold', an error will occur.  Generally, this setting
   * should not be changed except when working with specific POI/Polygon conflation use cases
   * that
   * require it.
   */
  getPoiPolygonReviewEvidenceThreshold : function() 
  {
      var tmp = hoot.get('poi.polygon.review.evidence.threshold');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 1; 
  },

  /**
   * List of key value pairs in the format 'key=value' or  'key,value' (UI only) for features to
   * always
   * review if marked as matches with POI to polygon conflation.  Delimit the individual types
   * with ';'.
   * e.g. 'amenity=school;shop=mall' or 'amenity,school;shop,mall'.  Also, when specifying the
   * list from
   * the command line, surround the entire value string in double quotes.
   */
  getPoiPolygonReviewIfMatchedTypes : function() 
  {
      var tmp = hoot.get('poi.polygon.review.if.matched.types');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return ""; 
  },

  /**
   * If true, POI to polygon conflation always marks matches between POIs and polygons where
   * multi-use
   * building polygons are present as needing review.  The definition of multi-use buildings is
   * controlled by the Hootenanny schema.
   */
  getPoiPolygonReviewMultiuseBuildings : function() 
  {
      var tmp = hoot.get('poi.polygon.review.multiuse.buildings');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * The threshold at which a review is called a review for PoiPolygon. See
   * `conflate.review.threshold.default`.
   */
  getPoiPolygonReviewThreshold : function() 
  {
      var tmp = hoot.get('poi.polygon.review.threshold');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${conflate.review.threshold.default}"); 
  },

  /**
   * The source tag key to be used in conjunction with
   * poi.polygon.disable.same.source.conflation.
   */
  getPoiPolygonSourceTagKey : function() 
  {
      var tmp = hoot.get('poi.polygon.source.tag.key');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return "source"; 
  },

  /**
   * The minimum similarity the type scores a POI and polygon can have and be considered a type
   * match, with 0.0 being the least similar and 1.0 being the most similar.
   */
  getPoiPolygonTypeScoreThreshold : function() 
  {
      var tmp = hoot.get('poi.polygon.type.score.threshold');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 0.7; 
  },

  /**
   * Flat file containing OSM types and lists of possible texts features having such a type might
   * contain.
   */
  getPoiPolygonTypeToNamesFile : function() 
  {
      var tmp = hoot.get('poi.polygon.type.to.names.file');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${HOOT_HOME}/conf/core/poi-polygon/poiPolygonTypeToNames"); 
  },

  /**
   * If true, Hootenanny will attempt to translate to English the value of any tag having a key
   * in its
   * schema.  This can have significant impact on the runtime performance of conflation when
   * enabled
   * and should only be enabled if the source data is known to have non-English type values.  The
   * configuration option, 'language.translation.translator', controls which translator is used.
   */
  getPoiPolygonTypeTranslateToEnglish : function() 
  {
      var tmp = hoot.get('poi.polygon.type.translate.to.english');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * The threshold at which a review is called a review for POIs. See
   * `conflate.review.threshold.default`.
   * 
   * See also:
   * 
   *  * _Estimate Pairwise Relationships_, <<hootalgo>>
   */
  getPoiReviewThreshold : function() 
  {
      var tmp = hoot.get('poi.review.threshold');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${conflate.review.threshold.default}"); 
  },

  /**
   * Automatically calculates the search radius to be used during conflation of power lines using
   * rubber
   * sheet tie point distances.  When this setting is enabled, rubbersheeting is not allowed as a
   * pre-conflation operation on the input data to be conflated.
   */
  getPowerLineAutoCalcSearchRadius : function() 
  {
      var tmp = hoot.get('power.line.auto.calc.search.radius');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return true; 
  },

  /**
   * A weighting coefficient value from 0.0 to 1.0 for the applying distance weighting to power
   * line
   * matches.  This will favor feature that are closer together.  The higher the coefficient
   * value, the
   * higher the weighting applied.  A value of 0.0 will disable distance weighting.
   */
  getPowerLineMatcherDistanceWeightCoefficient : function() 
  {
      var tmp = hoot.get('power.line.matcher.distance.weight.coefficient');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 0.01; 
  },

  /**
   * Sets that maximum angle that is still considered a power line match. Units in degrees.
   */
  getPowerLineMatcherMaxAngle : function() 
  {
      var tmp = hoot.get('power.line.matcher.max.angle');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 155.0; 
  },

  /**
   * The way subline matcher to use when determining matching power line sublines.
   */
  getPowerLineSublineMatcher : function() 
  {
      var tmp = hoot.get('power.line.subline.matcher');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return "hoot::FrechetSublineMatcher"; 
  },

  /**
   * Sets the progress reporting format to the type specified for classes that support progress
   * reporting.  Currently, 'json' is the only valid reporting format. If left blank, progress is
   * not
   * reported.
   */
  getProgressReportingFormat : function() 
  {
      var tmp = hoot.get('progress.reporting.format');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return ""; 
  },

  /**
   * A quantile value from 0.0 to 1.0 for the QuantileAggregator.
   */
  getQuantileAggregatorQuantile : function() 
  {
      var tmp = hoot.get('quantile.aggregator.quantile');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 0.0; 
  },

  /**
   * Distance, in meters, used for sampling railway data during angle histogram extraction with
   * the
   * SampledAngleHistogramExtractor
   */
  getRailwayAngleSampleDistance : function() 
  {
      var tmp = hoot.get('railway.angle.sample.distance');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 20.0; 
  },

  /**
   * The threshold at which a match is called a match for railwayss.
   * 
   * See also:
   * 
   *  * _Estimate Pairwise Relationships_, <<hootalgo>>
   */
  getRailwayMatchThreshold : function() 
  {
      var tmp = hoot.get('railway.match.threshold');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${conflate.match.threshold.default}"); 
  },

  /**
   * The distance around a point on a railway to look when calculating the heading. See
   * `way.matcher.heading.delta`.
   */
  getRailwayMatcherHeadingDelta : function() 
  {
      var tmp = hoot.get('railway.matcher.heading.delta');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 150.0; 
  },

  /**
   * Sets that maximum angle that is still considered a railway match. Units in degrees.
   */
  getRailwayMatcherMaxAngle : function() 
  {
      var tmp = hoot.get('railway.matcher.max.angle');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 90.0; 
  },

  /**
   * The threshold at which a miss is called a miss for railways.
   * 
   * See also:
   * 
   *  * _Estimate Pairwise Relationships_, <<hootalgo>>
   */
  getRailwayMissThreshold : function() 
  {
      var tmp = hoot.get('railway.miss.threshold');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${conflate.miss.threshold.default}"); 
  },

  /**
   * The threshold at which a review is called a review for railways.
   * 
   * See also:
   * 
   *  * _Estimate Pairwise Relationships_, <<hootalgo>>
   */
  getRailwayReviewThreshold : function() 
  {
      var tmp = hoot.get('railway.review.threshold');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${conflate.review.threshold.default}"); 
  },

  /**
   * The way subline matcher to use when determining matching sublines.
   */
  getRailwaySublineMatcher : function() 
  {
      var tmp = hoot.get('railway.subline.matcher');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return "hoot::MaximalSublineMatcher"; 
  },

  /**
   * The number of trees used to train a random forest conflation model.
   */
  getRandomForestModelTrees : function() 
  {
      var tmp = hoot.get('random.forest.model.trees');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 40; 
  },

  /**
   * By default add the `source:datetime` or `source:ingest:datetime` stamp when reading files.
   * Not
   * honored by all readers.
   */
  getReaderAddSourceDatetime : function() 
  {
      var tmp = hoot.get('reader.add.source.datetime');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return true; 
  },

  /**
   * Determines whether the reader used by the conflate command to read the first input dataset
   * will
   * use the element ID's specified by the input datasets (true) or use internal ID management
   * for the
   * inputs (false).
   */
  getReaderConflateUseDataSourceIds1 : function() 
  {
      var tmp = hoot.get('reader.conflate.use.data.source.ids.1');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return true; 
  },

  /**
   * Determines whether the reader used by the conflate command to read the second input dataset
   * will
   * use the element ID's specified by the input datasets (true) or use internal ID management
   * for the
   * inputs (false).
   */
  getReaderConflateUseDataSourceIds2 : function() 
  {
      var tmp = hoot.get('reader.conflate.use.data.source.ids.2');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * If reader.use.file.status is true, the default action is to drop the status tag from the
   * file
   * during reading.  Setting this to true preserves the status tag on the element.  Not honored
   * by
   * all readers.
   */
  getReaderKeepStatusTag : function() 
  {
      var tmp = hoot.get('reader.keep.status.tag');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * If true, all tags from the input data will be preserved.  Not honored by all readers.  e.g.
   * an 'accuracy' tag will not be replaced by a 'error:circular' tag; both tags will be kept.
   */
  getReaderPreserveAllTags : function() 
  {
      var tmp = hoot.get('reader.preserve.all.tags');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * Sets the status on data being read.  Valid values are "unknown1" and "unknown2".  Not
   * honored by all
   * readers.
   */
  getReaderSetDefaultStatus : function() 
  {
      var tmp = hoot.get('reader.set.default.status');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return "unknown1"; 
  },

  /**
   * If true, the element IDs in the source data will be assigned to written elements.
   * Otherwise,
   * Hootenanny manages element IDs internally.  This should not be set to true if any source
   * elements
   * have negative IDs.  Not honored by all readers.
   */
  getReaderUseDataSourceIds : function() 
  {
      var tmp = hoot.get('reader.use.data.source.ids');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return true; 
  },

  /**
   * By default should a reader use the file status from the file. Not honored by all readers.
   */
  getReaderUseFileStatus : function() 
  {
      var tmp = hoot.get('reader.use.file.status');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * The criterion used by RelationWithMostMembersOp to filter relation members.
   */
  getRelationWithMostMembersOpMemberCriterion : function() 
  {
      var tmp = hoot.get('relation.with.most.members.op.member.criterion');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return ""; 
  },

  /**
   * The criterion used by RelationWithMostMembersOp to filter relations.
   */
  getRelationWithMostMembersOpRelationCriterion : function() 
  {
      var tmp = hoot.get('relation.with.most.members.op.relation.criterion');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return ""; 
  },

  /**
   * List of element attributes to remove with the RemoveAttributesVisitor.  Valid values are:
   * changeset,
   * timestamp, user, uid, or version.
   */
  getRemoveAttributesVisitorTypes : function() 
  {
      var tmp = hoot.get('remove.attributes.visitor.types');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return ""; 
  },

  /**
   * Use this class for calculating the difference between element tags. If the difference is
   * exactly
   * 0 then they'll be a candidate for merging.
   */
  getRemoveDuplicateAreasDiff : function() 
  {
      var tmp = hoot.get('remove.duplicate.areas.diff');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return "hoot::ExactTagDifferencer"; 
  },

  /**
   * If set to true and multiple criterion are specified in
   * remove.elements.visitor.element.criteria,
   * elements will be removed only if they satisfy all of the criteria.  If set to false, then
   * only
   * one of the specified criteria must be met in order to remove an element.
   */
  getRemoveElementsVisitorChainElementCriteria : function() 
  {
      var tmp = hoot.get('remove.elements.visitor.chain.element.criteria');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * One or more element criteria used for selecting elements to remove. Delimit names with '='.
   * From
   * the command line, names with ';' and surround the entire list in double quotes.
   * E.g. "hoot::TagCriterion;hoot::ReviewRelationCriterion"
   */
  getRemoveElementsVisitorElementCriteria : function() 
  {
      var tmp = hoot.get('remove.elements.visitor.element.criteria');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return ""; 
  },

  /**
   * Should the element remover remove the elements recursively?
   */
  getRemoveElementsVisitorRecursive : function() 
  {
      var tmp = hoot.get('remove.elements.visitor.recursive');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return true; 
  },

  /**
   * The plugin name of an element criterion used to select tags to remove.  To pass in complex
   * nested criterion, use the Hootenanny Javascript interface instead.
   */
  getRemoveTagsVisitorElementCriterion : function() 
  {
      var tmp = hoot.get('remove.tags.visitor.element.criterion');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return ""; 
  },

  /**
   * A list of tag keys the RemoveTagsVisitor will remove on elements.  From the command line,
   * separate
   * list items with a semicolon and surround the entire list in double quotes.
   */
  getRemoveTagsVisitorKeys : function() 
  {
      var tmp = hoot.get('remove.tags.visitor.keys');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return ""; 
  },

  /**
   * The tag the ReplaceTagVisitor replaces, of the form key=value.
   */
  getReplaceTagVisitorMatchTag : function() 
  {
      var tmp = hoot.get('replace.tag.visitor.match.tag');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return ""; 
  },

  /**
   * The tag the ReplaceTagVisitor uses as a replacement tag; of the form key=value.
   */
  getReplaceTagVisitorReplaceTag : function() 
  {
      var tmp = hoot.get('replace.tag.visitor.replace.tag');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return ""; 
  },

  /**
   * If true, reviews outside of the score range specified by
   * review.score.criterion.min/max.threshold
   * will pass the filter.
   */
  getReviewScoreCriterionInvertThresholding : function() 
  {
      var tmp = hoot.get('review.score.criterion.invert.thresholding');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * The score threshold above which reviews will not pass the filter.  A value of 1.0 signifies
   * no
   * maximum score threshold.  This currently works with Attribute Conflation only and can be
   * enabled
   * with attribute.conflation.allow.reviews.by.score.
   */
  getReviewScoreCriterionMaxThreshold : function() 
  {
      var tmp = hoot.get('review.score.criterion.max.threshold');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 1.0; 
  },

  /**
   * The score threshold below which reviews will not pass the filter.  A value of 0.0 signifies
   * no
   * minimum score threshold.  This currently works with Attribute Conflation only and can be
   * enabled
   * with attribute.conflation.allow.reviews.by.score.
   */
  getReviewScoreCriterionMinThreshold : function() 
  {
      var tmp = hoot.get('review.score.criterion.min.threshold');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 0.0; 
  },

  /**
   * If set to true, then debug symbols will be added to nodes and additional tags will be added
   * to
   * matched nodes. This is a destructive operation that is only useful when debugging and should
   * not
   * be used during serious conflation.
   */
  getRubberSheetDebug : function() 
  {
      var tmp = hoot.get('rubber.sheet.debug');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * If set to true, rubber sheeting will return an error if less than rubber.sheet.minimum.ties
   * tie
   * points are found.  Otherwise, a warning will be logged and rubber sheeting will be skipped.
   */
  getRubberSheetFailWhenMinimumTiePointsNotFound : function() 
  {
      var tmp = hoot.get('rubber.sheet.fail.when.minimum.tie.points.not.found');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * If set to true, rubber sheeting will log a warning if any requirement for rubber sheeting is
   * not
   * met.  e.g less than rubber.sheet.minimum.ties tie points are found.  Otherwise, an info
   * level log
   * statement will be logged instead.  This setting is completely ignored if
   * rubber.sheet.fail.when.minimum.tie.points.not.found is set to true.
   */
  getRubberSheetLogMissingRequirementsAsWarning : function() 
  {
      var tmp = hoot.get('rubber.sheet.log.missing.requirements.as.warning');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return true; 
  },

  /**
   * The maximum number of interpolation optimization iterations, per optimization loop, an
   * interpolator
   * is allowed to run during rubber sheeting.  Use -1 for no iteration limit.  Not supported by
   * all
   * interpolators.  Can prevent runaway optimizations with some interpolators.  Lower values may
   * result
   * in the selection of a suboptimal interpolator.
   */
  getRubberSheetMaxInterpolatorIterations : function() 
  {
      var tmp = hoot.get('rubber.sheet.max.interpolator.iterations');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 200; 
  },

  /**
   * Sets the minimum number of tie points that will be used when calculating a rubbersheeting
   * solution.
   */
  getRubberSheetMinimumTies : function() 
  {
      var tmp = hoot.get('rubber.sheet.minimum.ties');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 4; 
  },

  /**
   * If this configuration setting is set to true, then the first layer is treated as the
   * reference
   * layer and will not be moved. If set to false the two layers will be moved towards each
   * other. The
   * weighting is determined based on the circular error.
   */
  getRubberSheetRef : function() 
  {
      var tmp = hoot.get('rubber.sheet.ref');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return true; 
  },

  /**
   * Export some of the images used when evaluating the graph connections between two maps
   * (`score`
   * command).
   */
  getScoreGraphDebugImages : function() 
  {
      var tmp = hoot.get('score.graph.debug.images');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * Remove REF tags from nodes before match scoring when using the score-matches command.
   */
  getScoreMatchesRemoveNodes : function() 
  {
      var tmp = hoot.get('score.matches.remove.nodes');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * For script test debugging only.  Sets a maximum allowed time, in seconds, for a script test
   * to run.
   * If the script runs longer than the specified time, then it is forcefully stopped by the
   * system.  If
   * the value is set to -1, then there is no time limit for script tests.  This is useful when
   * debugging tests which may hang on a remote build server.
   */
  getScriptTestMaxExecTime : function() 
  {
      var tmp = hoot.get('script.test.max.exec.time');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return -1; 
  },

  /**
   * Element criterion class which determines which input features are used for search radius
   * calculation.  An empty value specifies that all input features are to be used.  Conflation
   * routines
   * making use of automatic search radius calculation should set this value appropriately.
   */
  getSearchRadiusCalculatorElementCriterion : function() 
  {
      var tmp = hoot.get('search.radius.calculator.element.criterion');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return ""; 
  },

  /**
   * The default search radius to use when conflating features. If two features are within the
   * search
   * radius then they will be considered for conflation.  If the value is -1 then the circular
   * error will
   * be used to calculate an appropriate search radius.  Not all feature matching routines will
   * honor
   * the default value.
   */
  getSearchRadiusDefault : function() 
  {
      var tmp = hoot.get('search.radius.default');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return -1.0; 
  },

  /**
   * The search radius to use when conflating generic lines.  See `search.radius.default`.
   */
  getSearchRadiusGenericLine : function() 
  {
      var tmp = hoot.get('search.radius.generic.line');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${search.radius.default}"); 
  },

  /**
   * The search radius to use when conflating generic polygons.  See `search.radius.default`.
   */
  getSearchRadiusGenericPolygon : function() 
  {
      var tmp = hoot.get('search.radius.generic.polygon');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${search.radius.default}"); 
  },

  /**
   * The search radius to use when conflating highways.  See `search.radius.default`.
   */
  getSearchRadiusHighway : function() 
  {
      var tmp = hoot.get('search.radius.highway');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${search.radius.default}"); 
  },

  /**
   * The search radius to use when conflating railways.
   */
  getSearchRadiusRailway : function() 
  {
      var tmp = hoot.get('search.radius.railway');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 15; 
  },

  /**
   * The search radius to use when conflating waterways.  Not used if
   * waterway.auto.calc.search.radius = true.  See `search.radius.default`.
   */
  getSearchRadiusWaterway : function() 
  {
      var tmp = hoot.get('search.radius.waterway');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${search.radius.default}"); 
  },

  /**
   * If true, any element with a value populated for the key defined by the
   * set.tag.value.visitor.key
   * option will have the value specified in the set.tag.value.visitor.value option appended to
   * it.
   */
  getSetTagValueVisitorAppendToExistingValue : function() 
  {
      var tmp = hoot.get('set.tag.value.visitor.append.to.existing.value');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * The plugin name of an element criterion used to select elements to add or modify tags on.
   * To pass
   * in complex nested criteria, use the Hootenanny Javascript interface instead.
   */
  getSetTagValueVisitorElementCriterion : function() 
  {
      var tmp = hoot.get('set.tag.value.visitor.element.criterion');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return ""; 
  },

  /**
   * Set the key member in the SetTagValueVisitor class.  SetTagValueVisitor allows for
   * adding/modifying one or more tags on all elements in a map. The number of keys in
   * `set.tag.value.visitor.key` should match the number of keys in
   * `set.tag.value.visitor.value`.
   * Separate list items with a semicolon.
   */
  getSetTagValueVisitorKey : function() 
  {
      var tmp = hoot.get('set.tag.value.visitor.key');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return ""; 
  },

  /**
   * If true, the SetTagValueVisitor class will overwrite any existing tag it finds with
   * key=set.tag.value.visitor.key, otherwise it will skip updating the tag.
   */
  getSetTagValueVisitorOverwrite : function() 
  {
      var tmp = hoot.get('set.tag.value.visitor.overwrite');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return true; 
  },

  /**
   * Set the value member in the SetTagValueVisitor class.  SetTagValueVisitor allows for
   * adding/modifying one or more tags on all elements in a map.  Separate list items with a
   * semicolon.
   */
  getSetTagValueVisitorValue : function() 
  {
      var tmp = hoot.get('set.tag.value.visitor.value');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return ""; 
  },

  /**
   * Use this class for calculating the difference between element tags. If the difference is
   * exactly 0
   * then they'll be a candidate for merging.
   */
  getSmallWayMergerDiff : function() 
  {
      var tmp = hoot.get('small.way.merger.diff');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return "hoot::ExactTagDifferencer"; 
  },

  /**
   * If highways are smaller than threshold and the tags matched, then they will be merged
   * together into
   * a single way.
   */
  getSmallWayMergerThreshold : function() 
  {
      var tmp = hoot.get('small.way.merger.threshold');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 15; 
  },

  /**
   * If true, all tolerances use by the Unconnected Way Snapper will have the circular error of
   * the
   * snap node candidate added to them.
   */
  getSnapUnconnectedWaysAddCircularErrorToSearchRadius : function() 
  {
      var tmp = hoot.get('snap.unconnected.ways.add.circular.error.to.search.radius');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * The spacing granularity to which a unconnected way node is snapped back to a way with the
   * Unconnected Way Snapper.  Setting this too low could result in lower algorithm performance,
   * and
   * setting it too high may result in less accurate way snapping.
   */
  getSnapUnconnectedWaysDiscretizationSpacing : function() 
  {
      var tmp = hoot.get('snap.unconnected.ways.discretization.spacing');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 1.0; 
  },

  /**
   * Maximum distance used by the Unconnected Way Snapper, in meters, allowed between an
   * unconnected
   * way endpoint node and a neighboring way node for the way endpoint node to be snapped
   * directly to
   * the existing way node instead of adding the way endpoint node as a new way node on the way.
   */
  getSnapUnconnectedWaysExistingWayNodeTolerance : function() 
  {
      var tmp = hoot.get('snap.unconnected.ways.existing.way.node.tolerance');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 0.5; 
  },

  /**
   * If true, all way nodes snapped by the Unconnected Way Snapper to another way or way node
   * will be
   * marked with a 'hoot:snapped' tag.  Useful for debugging purposes.
   */
  getSnapUnconnectedWaysMarkSnappedNodes : function() 
  {
      var tmp = hoot.get('snap.unconnected.ways.mark.snapped.nodes');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * Optional criterion class to filter the types of ways being snapped to.  An example would be:
   * hoot::HighwayCriterion.  If no criterion is specified, then all ways are considered as
   * targets for
   * way snapping.
   */
  getSnapUnconnectedWaysSnapToWayCriterion : function() 
  {
      var tmp = hoot.get('snap.unconnected.ways.snap.to.way.criterion');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return "hoot::WayCriterion"; 
  },

  /**
   * Optional criterion class to filter the types of way nodes being snapped to.  An example
   * would be:
   * hoot::HighwayNodeCriterion.  If no criterion is specified, then all ways are considered as
   * targets
   * for way snapping.  This option is only used if snap.unconnected.ways.reuse.way.nodes is
   * enabled.
   */
  getSnapUnconnectedWaysSnapToWayNodeCriterion : function() 
  {
      var tmp = hoot.get('snap.unconnected.ways.snap.to.way.node.criterion');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return "hoot::WayNodeCriterion"; 
  },

  /**
   * Status of ways or way nodes being snapped.  Valid values are 'Input1' or 'Input2'.  Specify
   * 'Input1'
   * to snap reference ways or 'Input2' to snap secondary ways.
   */
  getSnapUnconnectedWaysSnapToWayStatus : function() 
  {
      var tmp = hoot.get('snap.unconnected.ways.snap.to.way.status');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return ""; 
  },

  /**
   * Maximum distance used by the Unconnected Way Snapper, in meters, allowed between an
   * unconnected
   * way endpoint node and a neighboring way for the way endpoint node to be snapped to the
   * closest
   * section of the neighboring way.
   */
  getSnapUnconnectedWaysSnapTolerance : function() 
  {
      var tmp = hoot.get('snap.unconnected.ways.snap.tolerance');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 5.0; 
  },

  /**
   * Optional criterion class to filter the types of ways being snapped.  An example would be:
   * hoot::HighwayCriterion.  If no criterion is specified, then all ways are considered as
   * sources for
   * way snapping.
   */
  getSnapUnconnectedWaysSnapWayCriterion : function() 
  {
      var tmp = hoot.get('snap.unconnected.ways.snap.way.criterion');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return "hoot::WayCriterion"; 
  },

  /**
   * Status of ways being snapped.  Valid values are 'Input1' or 'Input2'.  Specify 'Input1' to
   * snap reference ways 'Input2' to snap secondary ways.
   */
  getSnapUnconnectedWaysSnapWayStatus : function() 
  {
      var tmp = hoot.get('snap.unconnected.ways.snap.way.status');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return ""; 
  },

  /**
   * If true, when the Unconnected Way Snapper snaps way endpoint nodes to neighboring ways, it
   * will attempt to reuse existing way nodes on the way being snapped to instead of adding
   * the endpoint way node to the way.
   */
  getSnapUnconnectedWaysUseExistingWayNodes : function() 
  {
      var tmp = hoot.get('snap.unconnected.ways.use.existing.way.nodes');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return true; 
  },

  /**
   * The format used to write the element payload portion of the Spark changeset file.  Valid
   * options are
   * 'json' or 'xml'.
   */
  getSparkChangesetWriterElementPayloadFormat : function() 
  {
      var tmp = hoot.get('spark.changeset.writer.element.payload.format');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return "json"; 
  },

  /**
   * The maximum length, in characters, that the SplitNameVisitor will allow for a name tag.
   */
  getSplitNameVisitorMaxLength : function() 
  {
      var tmp = hoot.get('split.name.visitor.max.length');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 255; 
  },

  /**
   * Path to the translation script to use when translating tags for stats. If the path is empty,
   * then
   * all translation stats are disabled.
   */
  getStatsTranslateScript : function() 
  {
      var tmp = hoot.get('stats.translate.script');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${HOOT_HOME}/translations/TDSv61.js"); 
  },

  /**
   * The default status to match with a status criterion.  Used by various element visitors and
   * map
   * operations.
   */
  getStatusCriterionStatus : function() 
  {
      var tmp = hoot.get('status.criterion.status');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return "Invalid"; 
  },

  /**
   * If true, the SetTagValueVisitor class will only update statuses on elements when the
   * existing
   * status is 'Invalid'.
   */
  getStatusUpdateVisitorOnlyUpdateInvalidStatus : function() 
  {
      var tmp = hoot.get('status.update.visitor.only.update.invalid.status');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * Adds the specified status to elements.  Valid values are: 'Unknown1', 'Unknown2',
   * 'Conflated', or
   * 'Invalid'.  If left empty, all elements will receive tag additions.
   */
  getStatusUpdateVisitorStatus : function() 
  {
      var tmp = hoot.get('status.update.visitor.status');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return ""; 
  },

  /**
   * Flat file containing street types and their abbreviations.
   */
  getStreetTypesFile : function() 
  {
      var tmp = hoot.get('street.types.file');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${HOOT_HOME}/conf/core/streetTypes"); 
  },

  /**
   * The default ancestor to use when using the hoot::TagAncestorDifferencer class for comparing
   * tags.
   * Primarily, this is useful within the node.js interface.
   */
  getTagAncestorDifferencerName : function() 
  {
      var tmp = hoot.get('tag.ancestor.differencer.name');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return ""; 
  },

  /**
   * The default category to use when using the hoot::TagCategoryDifferencer class for comparing
   * tags.
   * Primarily, this is useful within the node.js interface.
   */
  getTagCategoryDifferencerName : function() 
  {
      var tmp = hoot.get('tag.category.differencer.name');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return ""; 
  },

  /**
   * Key/value pairs to use with TagCriterion. Delimit keys and values with '='.  From the
   * command line,
   * delimit multiple key/value pairs with ';' and surround the entire list in double quotes.
   * E.g. "highway=road;amenity=school"
   */
  getTagCriterionKvps : function() 
  {
      var tmp = hoot.get('tag.criterion.kvps');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return ""; 
  },

  /**
   * Text that TagKeyContainsCriterion uses to filter elements.
   */
  getTagKeyContainsCriterionText : function() 
  {
      var tmp = hoot.get('tag.key.contains.criterion.text');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return ""; 
  },

  /**
   * Tag keys that TagKeyCriterion uses to filter elements. From the command line, delimit
   * multiple
   * key/value pairs with ';' and surround the entire list in double quotes.
   */
  getTagKeyCriterionKeys : function() 
  {
      var tmp = hoot.get('tag.key.criterion.keys');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return ""; 
  },

  /**
   * Specifies the default way of merging tags. This is used by most merge routines, but may be
   * overriden
   * depending on the specifics of the merger. 'hoot info --tag-mergers' displays information
   * about the
   * available mergers.
   */
  getTagMergerDefault : function() 
  {
      var tmp = hoot.get('tag.merger.default');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return "hoot::OverwriteTag2Merger"; 
  },

  /**
   * Output format to use when printing OSM+ Tag documentation. Valid formats are: 'csv', 'html',
   * 'redmine' & 'asciidoc' (default)
   */
  getTagPrintingFormat : function() 
  {
      var tmp = hoot.get('tag.printing.format');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return "asciidoc"; 
  },

  /**
   * The translation script to use when printing OSM+ Tag documentation.
   */
  getTagPrintingScript : function() 
  {
      var tmp = hoot.get('tag.printing.script');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${HOOT_HOME}/translations/PrintOsmDocs.js"); 
  },

  /**
   * The key to used to replace an existing by the TagRenameKeyVisitor.  TagRenameKeyVisitor
   * allows for
   * renaming existing tag keys on all elements in a map.
   */
  getTagRenameVisitorNewKey : function() 
  {
      var tmp = hoot.get('tag.rename.visitor.new.key');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return ""; 
  },

  /**
   * The key to be replaced by the TagRenameKeyVisitor.  TagRenameKeyVisitor allows for
   * renaming existing tag keys on all elements in a map.
   */
  getTagRenameVisitorOldKey : function() 
  {
      var tmp = hoot.get('tag.rename.visitor.old.key');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return ""; 
  },

  /**
   * The keys the TagValueNumericRangeCriterion examines the numeric value of.  Tags for all keys
   * must
   * meet the numeric range requirement for the criterion to be met.  Separate multiple keys with
   * a
   * semicolon from the command line and surround the entire list in double quotes.
   */
  getTagValueNumericRangeCriterionKeys : function() 
  {
      var tmp = hoot.get('tag.value.numeric.range.criterion.keys');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return ""; 
  },

  /**
   * Minimum tag numeric value that will allow the TagValueNumericRangeCriterion to be
   * satisified.
   */
  getTagValueNumericRangeCriterionMax : function() 
  {
      var tmp = hoot.get('tag.value.numeric.range.criterion.max');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return -1; 
  },

  /**
   * Minimum tag numeric value that will allow the TagValueNumericRangeCriterion to be
   * satisified.
   */
  getTagValueNumericRangeCriterionMin : function() 
  {
      var tmp = hoot.get('tag.value.numeric.range.criterion.min');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return -1; 
  },

  /**
   * List of tag keys for which the AverageNumericTagsVisitor, SumNumericTagsVisitor, or
   * TagKeyCountVisitor uses.  Separate keys with a ';' and surround entire list in double quotes
   * when
   * passing in from the command line.
   */
  getTagsVisitorKeys : function() 
  {
      var tmp = hoot.get('tags.visitor.keys');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return ""; 
  },

  /**
   * For commands supporting it, the iteration count at which a status message should be logged.
   * This
   * setting may have a negative impact on performance if set to a very low value.
   */
  getTaskStatusUpdateInterval : function() 
  {
      var tmp = hoot.get('task.status.update.interval');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 1000; 
  },

  /**
   * Set the conflate command that should be used in a test case. This is only useful when
   * writing
   * test cases (`test-files/cases/`) and was originally added to support the
   * MultiaryPoiConflateCmd.
   */
  getTestCaseCmd : function() 
  {
      var tmp = hoot.get('test.case.cmd');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return "hoot::ConflateCmd"; 
  },

  /**
   * Always force the orthographic projection when determining a proper planar projection. In
   * typical
   * usage this will never be used (the automatically selected projection should always be at
   * least as
   * good). This is most useful if you want to get consistent results even if the list of
   * potential
   * projections change over time. Very handy in unit tests.
   */
  getTestForceOrthographicProjection : function() 
  {
      var tmp = hoot.get('test.force.orthographic.projection');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * This does a rudimentary check to see if the string contains any letters/numbers. If the
   * string
   * doesn't contain any letters or numbers then it will be dropped. Examples that would be
   * dropped
   * if the value is `true` include:
   * 
   * * `&`
   * * `--`
   * 
   * Examples that will be kept if the value is `true` include:
   * 
   * * `1&2`
   * * `Joe's`
   */
  getTokenKeepNonWords : function() 
  {
      var tmp = hoot.get('token.keep.non.words');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * This is the minimum string size that the string tokenizer should accept as a token. If the
   * string
   * length is less than this value, then it will not be accepted. Set the value to 0 if you want
   * to
   * accept all strings.
   * 
   * This setting primarily applies to string comparison functions and will eliminate comparing
   * very
   * short strings such as "of" or "&".
   */
  getTokenMinSize : function() 
  {
      var tmp = hoot.get('token.min.size');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 3; 
  },

  /**
   * The token separator defined as a regular expression. This is used in some methods for
   * tokenizing
   * names. The default value matches multiple whitespace characters.
   * 
   * Another useful option is `[\s-,';]+`. This will split on white space, or several forms of
   * punctuation. See http://doc.qt.io/qt-4.8/QRegExp.html for a useful list of regular
   * expression
   * options.
   */
  getTokenSeparator : function() 
  {
      var tmp = hoot.get('token.separator');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return "\s+"; 
  },

  /**
   * Set to true if the strings should be tokenized (split into words) before translating the
   * values.
   * Only applies if language.translation.translator is set to hoot::DictionaryTranslator.
   */
  getTranslateStringDistanceTokenize : function() 
  {
      var tmp = hoot.get('translate.string.distance.tokenize');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return true; 
  },

  /**
   * If true and language.translation.translator is set to hoot::DictionaryTranslator, will
   * attempt to
   * retrieve multiple translations when scoring string comparisons.  Otherwise, only a single
   * translation is retrieved.
   */
  getTranslateStringDistanceTranslateAll : function() 
  {
      var tmp = hoot.get('translate.string.distance.translate.all');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return true; 
  },

  /**
   * Semi-colon delimited list of tags that should be ignored when comparing a list of tags using
   * the
   * hoot::TranslatedTagDifferencer.
   * 
   * See also:
   * * `translated.tag.differencer.script`
   */
  getTranslatedTagDifferencerIgnoreList : function() 
  {
      var tmp = hoot.get('translated.tag.differencer.ignore.list');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return ""; 
  },

  /**
   * Path to the translation script when using the hoot::TranslatedTagDifferencer. The
   * hoot::TranslatedTagDifferencer is most useful when deciding how difference between two sets
   * of
   * tags should be calculated.
   * 
   * This differencer can be used with:
   * 
   * * `small.way.merger.diff`
   * * `remove.duplicate.areas.diff`
   */
  getTranslatedTagDifferencerScript : function() 
  {
      var tmp = hoot.get('translated.tag.differencer.script');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return ""; 
  },

  /**
   * The direction that the translation script should translate. `toogr` will translate from OSM
   * to OGR.
   * `toosm` will translate from OSM to OGR. This is useful with the hoot::TranslationOp.
   */
  getTranslationDirection : function() 
  {
      var tmp = hoot.get('translation.direction');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return "toosm"; 
  },

  /**
   * Override the value of translated tags and attributes.
   * 
   * VERY IMPORTANT NOTE: The changes apply to ALL elements and are applied to the OSM+ tags
   * either
   * before or after the translation. E.g.
   * * After attributes are translated to OSM+ tags during Import
   * * Before OSM+ tags are translated to attributes on Export
   * 
   * NOTE: This assumes that you know exactly what tags you want to modify/delete
   */
  getTranslationOverride : function() 
  {
      var tmp = hoot.get('translation.override');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return ""; 
  },

  /**
   * The script used by the TranslationVisitor for translation.
   */
  getTranslationScript : function() 
  {
      var tmp = hoot.get('translation.script');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return ""; 
  },

  /**
   * The maximum size of the cache used by DictionaryTranslator for transliterations.  A cache
   * size of -1
   * disables the transliteration cache.
   */
  getTransliterationMaxCacheSize : function() 
  {
      var tmp = hoot.get('transliteration.max.cache.size');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return -1; 
  },

  /**
   * Enable the calculation of Optimal Constrained Matches during conflation. When enabled,
   * Hootenanny
   * will use either Optimal Constrained Matches (via GLPK) or Greedy Constrained Matches. If
   * disabled,
   * Hootenanny will only use Greedy Constrained Matches.
   */
  getUnifyEnableOptimalConstrainedMatches : function() 
  {
      var tmp = hoot.get('unify.enable.optimal.constrained.matches');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return true; 
  },

  /**
   * The maximum amount of time in seconds to wait for the optimizer to complete. A value of -1
   * makes
   * the wait time limit unlimited.
   * 
   * If this value is set to something other than -1 your conflation results may change between
   * multiple
   * runs. Especially if the machine Hoot is running on is under heavy load. If the "CM Score:"
   * value
   * is changing between runs and GLPK isn't finding an optimal solution then this is likely
   * causing
   * different output.  Just because the output is changing doesn't mean it is wrong, but this
   * can be
   * problematic if you're doing testing or expecting repeatable output for other.
   */
  getUnifyOptimizerTimeLimit : function() 
  {
      var tmp = hoot.get('unify.optimizer.time.limit');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 60; 
  },

  /**
   * Creates a repeatable UUID for the features. This is useful for debugging, but shouldn't be
   * used in
   * normal operation.
   */
  getUuidHelperRepeatable : function() 
  {
      var tmp = hoot.get('uuid.helper.repeatable');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * Distance, in meters, used for sampling river data during angle histogram extraction with the
   * SampledAngleHistogramExtractor
   */
  getWaterwayAngleSampleDistance : function() 
  {
      var tmp = hoot.get('waterway.angle.sample.distance');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 20.0; 
  },

  /**
   * Automatically calculates the search radius to be used during conflation of waterways using
   * rubber
   * sheet tie point distances.  When this setting is enabled, rubbersheeting is not allowed as a
   * pre-conflation operation on the input data to be conflated.
   */
  getWaterwayAutoCalcSearchRadius : function() 
  {
      var tmp = hoot.get('waterway.auto.calc.search.radius');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return true; 
  },

  /**
   * The threshold at which a match is called a match for waterways.
   * 
   * See also:
   * 
   *  * _Estimate Pairwise Relationships_, <<hootalgo>>
   */
  getWaterwayMatchThreshold : function() 
  {
      var tmp = hoot.get('waterway.match.threshold');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${conflate.match.threshold.default}"); 
  },

  /**
   * The distance around a point on a waterway to look when calculating the heading. See
   * `way.matcher.heading.delta`.
   */
  getWaterwayMatcherHeadingDelta : function() 
  {
      var tmp = hoot.get('waterway.matcher.heading.delta');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 150.0; 
  },

  /**
   * Sets that maximum angle that is still considered a waterway match. Units in degrees.
   */
  getWaterwayMatcherMaxAngle : function() 
  {
      var tmp = hoot.get('waterway.matcher.max.angle');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 90.0; 
  },

  /**
   * The threshold at which a miss is called a miss for waterways.
   * 
   * See also:
   * 
   *  * _Estimate Pairwise Relationships_, <<hootalgo>>
   */
  getWaterwayMissThreshold : function() 
  {
      var tmp = hoot.get('waterway.miss.threshold');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${conflate.miss.threshold.default}"); 
  },

  /**
   * The threshold at which a review is called a review for waterways.
   * 
   * See also:
   * 
   *  * _Estimate Pairwise Relationships_, <<hootalgo>>
   */
  getWaterwayReviewThreshold : function() 
  {
      var tmp = hoot.get('waterway.review.threshold');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${conflate.review.threshold.default}"); 
  },

  /**
   * Sets the minimum number of tie points that will be used when calculating a rubber sheeting
   * solution
   * with river data.
   */
  getWaterwayRubberSheetMinimumTies : function() 
  {
      var tmp = hoot.get('waterway.rubber.sheet.minimum.ties');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 5; 
  },

  /**
   * See `rubber.sheet.ref`.  Used during waterway conflation.
   */
  getWaterwayRubberSheetRef : function() 
  {
      var tmp = hoot.get('waterway.rubber.sheet.ref');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return true; 
  },

  /**
   * The way subline matcher to use when determining matching sublines.
   */
  getWaterwaySublineMatcher : function() 
  {
      var tmp = hoot.get('waterway.subline.matcher');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return "hoot::MaximalSublineMatcher"; 
  },

  /**
   * Distance, in meters, used for sampling way data during angle histogram extraction with the
   * SampledAngleHistogramExtractor
   */
  getWayAngleSampleDistance : function() 
  {
      var tmp = hoot.get('way.angle.sample.distance');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 10.0; 
  },

  /**
   * The way joiner implementation to use to repair way splits after a conflation job.
   */
  getWayJoiner : function() 
  {
      var tmp = hoot.get('way.joiner');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return "hoot::WayJoiner1"; 
  },

  /**
   * The distance around a point on a way to look when calculating the heading. A larger value
   * will
   * smooth out the heading values on a line. A smaller value will make the heading values
   * correspond
   * directly to the heading on the way at that point. This is primarily used in subline
   * matching.
   * Values are in meters.
   */
  getWayMatcherHeadingDelta : function() 
  {
      var tmp = hoot.get('way.matcher.heading.delta');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 5.0; 
  },

  /**
   * Sets the maximum angle that is still considered a way match. Units in degrees.
   */
  getWayMatcherMaxAngle : function() 
  {
      var tmp = hoot.get('way.matcher.max.angle');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 60.0; 
  },

  /**
   * If unset, or set to zero, there will be no maximum number of nodes stored in a way. If the
   * value is
   * set to a non-zero positive value, all ways which contain more nodes than this value will be
   * broken
   * up into two or more separate ways, and all of them will contain this number of nodes (or
   * less).
   * The original way will be removed from the map. Default set to 1900 as OSM imports through
   * OSM API
   * databases are capped at 2000 nodes per way.
   */
  getWayMaxNodesPerWay : function() 
  {
      var tmp = hoot.get('way.max.nodes.per.way');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 1900; 
  },

  /**
   * The minimum size that a way should be split into for merging. Units in meters.
   */
  getWayMergerMinSplitSize : function() 
  {
      var tmp = hoot.get('way.merger.min.split.size');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 5; 
  },

  /**
   * Bounds used by the RemoveWaysByBoundsOp when removing ways, of the form: minx,miny,maxx,maxy
   */
  getWayRemoverBounds : function() 
  {
      var tmp = hoot.get('way.remover.bounds');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return ""; 
  },

  /**
   * If true, the RemoveWaysByBoundsOp will remove ways outside of the bounds specified by
   * way.remover.bounds.  Otherwise it will remove ways within the specified bounds.
   */
  getWayRemoverInvertBounds : function() 
  {
      var tmp = hoot.get('way.remover.invert.bounds');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * This configuration option is used by hoot::WaySplitterOp. If a way is longer than this
   * length
   * (in meters) then it will be split into smaller ways.
   */
  getWaySplitterMaxLength : function() 
  {
      var tmp = hoot.get('way.splitter.max.length');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 5000; 
  },

  /**
   * The way subline matcher to use when determining matching sublines.
   */
  getWaySublineMatcher : function() 
  {
      var tmp = hoot.get('way.subline.matcher');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return "hoot::MaximalNearestSublineMatcher"; 
  },

  /**
   * The way subline string matcher to use when determining matching sublines.
   */
  getWaySublineStringMatcher : function() 
  {
      var tmp = hoot.get('way.subline.string.matcher');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return "hoot::MaximalSublineStringMatcher"; 
  },

  /**
   * Type of point aggregator used by the WeightedMetricDistanceExtractor.
   */
  getWeightedMetricDistanceExtractorPointAggregator : function() 
  {
      var tmp = hoot.get('weighted.metric.distance.extractor.point.aggregator');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return "hoot::MeanAggregator"; 
  },

  /**
   * The search radius used by the WeightedMetricDistanceExtractor.  Units in meters.  Defaults
   * to a
   * value computed from the circular error for each way being examined.
   */
  getWeightedMetricDistanceExtractorSearchRadius : function() 
  {
      var tmp = hoot.get('weighted.metric.distance.extractor.search.radius');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return -1.0; 
  },

  /**
   * Location of the abridged word frequency dictionary. This is not ideal and you'll get
   * repeated
   * warnings if you use it, but at least you won't need to download a 400MB+ file.
   */
  getWeightedWordDistanceAbridgedDictionary : function() 
  {
      var tmp = hoot.get('weighted.word.distance.abridged.dictionary');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return "dictionary/WordsAbridged.sqlite"; 
  },

  /**
   * Location of the word frequency dictionary. If the absolute file path isn't found, then
   * the local `conf` and `$HOOT_HOME/conf` directories will be searched.
   * 
   * This file is typically downloaded from:
   * https://s3.amazonaws.com/hoot-support/words1.sqlite.bz2
   */
  getWeightedWordDistanceDictionary : function() 
  {
      var tmp = hoot.get('weighted.word.distance.dictionary');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return "dictionary/words.sqlite"; 
  },

  /**
   * The weight used will be `1.0 / (w ^ p)` where w is the frequency. Valid values are >= 0, but
   * generally it should be `1 >= p >= 0`.
   */
  getWeightedWordDistanceProbability : function() 
  {
      var tmp = hoot.get('weighted.word.distance.probability');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 1.0; 
  },

  /**
   * If true, Hootenanny review tags are treated as metadata tags and will be removed by the
   * NoInformationElementRemover cleaning operation.
   */
  getWriterCleanReviewTags : function() 
  {
      var tmp = hoot.get('writer.clean.review.tags');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return true; 
  },

  /**
   * When true, writers will include circular error information. Not honored by all writers.
   */
  getWriterIncludeCircularErrorTags : function() 
  {
      var tmp = hoot.get('writer.include.circular.error.tags');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return true; 
  },

  /**
   * Add detailed review tags to review relations during conflation.  Turning this setting off is
   * generally only done in debugging environments.  This setting allows for partitioning the
   * level of
   * detail in the review relation tags into two groups.  Turning this setting off can be useful
   * during
   * debugging in situations where you are comparing map outputs and want to see reviews in the
   * output
   * but are not concerned with a higher level of review detail.  Disabling this setting will
   * also
   * disable AddHilbertReviewSortOrderOp, the output of which is depended upon by the Hootenanny
   * user
   * interface.
   */
  getWriterIncludeConflateReviewDetailTags : function() 
  {
      var tmp = hoot.get('writer.include.conflate.review.detail.tags');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return true; 
  },

  /**
   * Add match/miss/review score values to elements with matches during Unifying Conflation. This
   * is
   * useful for debugging.
   */
  getWriterIncludeConflateScoreTags : function() 
  {
      var tmp = hoot.get('writer.include.conflate.score.tags');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * When true, writers will include debug information (hoot:* tags; e.g. status). Not honored by
   * all
   * writers.
   */
  getWriterIncludeDebugTags : function() 
  {
      var tmp = hoot.get('writer.include.debug.tags');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * Set the output precision when writing. Not honored by all writers.
   */
  getWriterPrecision : function() 
  {
      var tmp = hoot.get('writer.precision');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return 16; 
  },

  /**
   * Add hoot:status values as text (Reference, Merged etc) instead of numbers (1,2,3)
   */
  getWriterTextStatus : function() 
  {
      var tmp = hoot.get('writer.text.status');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return false; 
  },

  /**
   * If true, OSM elements written to XML file output (.osm) are sorted by ID.  Setting this to
   * true
   * will require reading the entire source dataset into memory.  Setting it to false may result
   * in
   * using smaller amounts of memory during writing if the data source being written is also a
   * streamable
   * format (see the "Supported Data Formats" section in README.md).
   */
  getWriterXmlSortById : function() 
  {
      var tmp = hoot.get('writer.xml.sort.by.id');
      if (tmp) 
      {

        return tmp;
      }

      // Return the default value
      return true; 
  },

    } // End of config
    